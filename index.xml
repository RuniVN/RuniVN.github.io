<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Runi blog</title>
    <link>https://runivn.github.io/index.xml</link>
    <description>Recent content on Runi blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Mar 2017 16:45:32 +0700</lastBuildDate>
    <atom:link href="https://runivn.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Goroutine under the hood</title>
      <link>https://runivn.github.io/post/go-routine-under-the-hood/</link>
      <pubDate>Tue, 28 Mar 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-routine-under-the-hood/</guid>
      <description>

&lt;p&gt;Chắc các bạn cũng không lạ lẫm gì Go nữa, Go là một ngôn ngữ backend được phát triển bởi Google.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/h46t11xlnx_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Một vài điểm mạnh nổi bật trong Go:
- Static binaries
- Concurrency
- High performance&lt;/p&gt;

&lt;p&gt;Trong đó concurrency được coi là first class citizen. Trong bài này mình sẽ đi sâu vào goroutines và cơ chế hoạt động của nó.&lt;/p&gt;

&lt;h1 id=&#34;một-ít-kiến-thức-căn-bản&#34;&gt;Một ít kiến thức căn bản&lt;/h1&gt;

&lt;p&gt;###Phân biệt parallelism và concurrenncy:
Cả hai đều là cách để thực hiện multi processing programming, nhưng:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concurrency là việc handle nhiều thứ cùng một lúc. Thử tưởng tượng bạn đang tung bóng và bắt bóng trên tay, bạn có 4 quả bóng, nhưng một lúc bạn chỉ có thể tung một quả bằng tay phải, giữ một quả bằng tay trái và hai quả còn lại ở trên bầu trời.&lt;/li&gt;
&lt;li&gt;Parallelism là việc nhiều tác vụ đang chạy cùng một lúc(ví dụ multi processor). Bạn có thể vừa giặt đồ, vừa đọc sách, 2 tác vụ này chạy song song với nhau và không cần xài chung tài nguyên gì.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;phân-biệt-preemptive-scheduling-và-cooperative-scheduling&#34;&gt;Phân biệt preemptive scheduling và cooperative scheduling:&lt;/h3&gt;

&lt;p&gt;Tại mỗi thời điểm chỉ có một process được thực thi, vì vậy sẽ có nhiều loại scheduling CPU sao cho đạt hiệu quả tùy mục đích sử dụng nhất.
 - Preemptive scheduling là khi các process sẵn sàng nhường quyền điều khiển CPU.
 - Cooperative(hay còn gọi là non premptive): Khi một process được điều phối CPU, nó sẽ sử dụng CPU cho đến khi nó giải phóng(bằng cách kết thúc hoặc qua next state).&lt;/p&gt;

&lt;p&gt;###Phân biệt process, thread và goroutine:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Process hiểu nôm na là một tiến trình xử lý của máy tính. Thuở xa xưa, máy tính chỉ chạy được một process trong một thời điểm. Khi multi processing ra đời, &lt;a href=&#34;https://en.wikipedia.org/wiki/Time-sharing&#34;&gt;time sharing model&lt;/a&gt; trở nên phổ biến. Mỗi process sẽ cung cấp resource riêng biệt để thực hiện chương trình.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Time sharing là một cách để share resource của máy tính cho các process, hay nói cách khác là các process có thể đồng thời làm việc trên một single core computer.&lt;/p&gt;

&lt;p&gt;Nói vậy thôi, nhưng nó chỉ là &amp;ldquo;ảo ảnh&amp;rdquo; của concurrency. Thực chất trong đó là việc switch sự phân bố của CPU rất nhanh giữa các active process với nhau. Để làm được chuyện đó cần phải lưu lại state của một process, và khởi động lại state của một process khác.&lt;/p&gt;

&lt;p&gt;Đó chính là context switching.&lt;/p&gt;

&lt;p&gt;Context switching cost cho các process rất nặng nề, bao gồm việc phải store tất cả register của CPU.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Thấy nặng nề quá nên đẻ ra thằng thread. Thread thật ra giống y chang process, nhưng nó là thực thể nằm trong process, và được cái là cho phép share resource. Process này không thể xài chung tài nguyên với process khác, nhưng thread trong cùng một process có thể xài chung tài nguyên với nhau.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tuy vậy, cost để context switching giữa các thread còn khá cao, vì mỗi thread cũng chứa rất nhiều state.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Goroutine lấy ý tưởng của thread và phát huy. Thử tìm hiểu xem sao.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;goroutine&#34;&gt;Goroutine&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/fy6g2oyuqm_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Các bạn hiểu nôm na một goroutine là một function mà có thể chạy đồng thời với các function khác. Các goroutine share nhau address space.
Không khác gì thread nhỉ?&lt;/p&gt;

&lt;p&gt;Một số đặc điểm goroutine:
- Goroutine là cooperative.
- Compiler sẽ biết register nào được sử dụng vào tự động lưu nó
- Context switch của Goroutine xảy ra ở 2 thời điểm: khi một go routine đang chờ data để xử lý (channel operation) hoặc cần thêm space để nhét data (IO, GC).&lt;/p&gt;

&lt;h1 id=&#34;so-sánh-goroutine-và-thread&#34;&gt;So sánh goroutine và thread&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Về bộ nhớ: Bạn khởi tạo một goroutine chỉ mất 4Kb stack trong khi khởi tạo một thread thì lại cần từ 1- 4Mb. =&amp;gt; Dùng goroutine để multiplex request cho server vô cùng đơn giản khi bạn có thể spawn cả chục nghìn go routine, còn nếu 1 thread - 1 request thì rất dễ dẫn tới out of memory.&lt;/li&gt;
&lt;li&gt;Setup/teardown cost: Thread sẽ expensive trong việc này vì bạn phải request OS resource và trả lại khi dùng xong(thường cách hay dùng sẽ là thread pool để hạn chế việc này). Còn với goroutine thì việc khởi tạo/hủy đều thực hiện ở run time và cost cho việc này rất rẻ.&lt;/li&gt;
&lt;li&gt;Context switching: Thread sử dụng preemptive scheduling, khi switch phải save/restore 16 registers trong khi Go routine sử dụng cooperative và chỉ cần 3 register(PC, DX, SP).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;multiplex-goroutine&#34;&gt;Multiplex goroutine&lt;/h1&gt;

&lt;p&gt;Bởi vì Goroutine là cooperative, nên OS gần như không còn dính dáng tới việc đưa ra quyết định schedule. Đảm nhận việc này là Go scheduler.&lt;/p&gt;

&lt;p&gt;Có 3 model cơ bản trong multi threading. Đó là N:1, 1:1 và N:M
- N:1(user space thread) là khi có nhiều thread chạy trên cùng một OS thread. Cùng một OS thread thì cho phép việc context switch rất nhanh, nhưng lại không thể tận dụng được multi core system. Tức là trong một lúc chỉ có một thread được execute, như vậy nếu 1 thread đang bị block bởi IO, thì mấy thread khác cũng không thể làm gì được.
- 1:1(kernel thread) là 1 thread sẽ gắn với một OS thread. Cái này thì multi core được, nhưng context switch lại expensive.
- N:M, đây là cách của Go sử dụng, chắc các bạn cũng đoán được, đó là N go routines sẽ chạy được trên M OS thread. Như vậy sẽ vừa quick context switch vừa tận dụng được multi core. Cơ mà để làm được như vậy, thì Go scheduler phải tay to, và xử lý cực kì phức tạp.&lt;/p&gt;

&lt;h1 id=&#34;go-scheduler&#34;&gt;Go scheduler&lt;/h1&gt;

&lt;p&gt;Trong Go scheduler sẽ có 3 thực thể. M P G&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7tt20uu4gq_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;M đại diện cho OS thread.(machine)&lt;/p&gt;

&lt;p&gt;P là processor, nó sẽ giữ context tương ứng với một OS thread.&lt;/p&gt;

&lt;p&gt;G là goroutine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ndz0upn5ir_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Trên hình trên chúng ta thấy được 2 M, có giữ context P, mỗi cái sẽ chạy một goroutine G (Lưu ý là để chạy goroutine, M phải giữ context P)&lt;/p&gt;

&lt;p&gt;G màu xám là những go routine đang pending, và sẵn sàng để được schedule. Mỗi context P sẽ nắm giữ một list G màu xám như vậy. Cứ mỗi &lt;code&gt;go&lt;/code&gt; statement được chạy, nó sẽ được add vào run queue. Khi tới thời điểm, context sẽ pop một goroutine ra, allocate cho nó lên stack, set cho nó một instruction pointer và cho nó chạy.&lt;/p&gt;

&lt;p&gt;M và G hẳn là đã rõ rồi, cơ mà P ở đây vai trò là gì? Tại sao không gắn thẳng goroutine vào thread mà phải thông qua context?&lt;/p&gt;

&lt;p&gt;Nó sẽ rơi vào trường hợp sau đây, đó là khi thread đang chạy bị block. Nguyên nhân gây ra block có thể là IO hay GC.
Ví dụ khi gọi system call, ghi file chẳng hạn, thì trong thời gian block, go scheduler sẽ pass context này cho thread khác để có thể tiếp tục chạy.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/djsaexr43v_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Như hình trên, M0 đang handling một cái syscall, điều này làm những goroutine trong running queue sẽ ko được schedule, nên Go scheduler sẽ pass context P cho M1. Lưu ý là M1 có thể được tạo ra trong lúc đó, hoặc lấy ra từ thread cache.&lt;/p&gt;

&lt;p&gt;Khi M0 làm xong syscall, thì nó sẽ:
- Tìm kiếm xung quanh, bằng cách chôm &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; goroutine run queue của thread khác
- Nếu không tìm thấy gì, nó sẽ đặt mình vào thread cache và ngủ.&lt;/p&gt;

&lt;h1 id=&#34;tại-sao-goroutine-lại-nhẹ-như-vậy&#34;&gt;Tại sao Goroutine lại nhẹ như vậy?&lt;/h1&gt;

&lt;p&gt;Để khởi tạo goroutine chỉ mất tầm 4KB trong khi bạn cần 4Mb để có thể tạo ra một thread.&lt;/p&gt;

&lt;p&gt;Lí do là Goroutine có thể tăng/giảm kích thước khi cần trong lúc runtime(dynamic allocation).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/5nb52d9gmf_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Go sử dụng segmented stacks. Cho các bạn chưa biết thì segmented stacks là loại stack mà cho phép tăng/giảm stack space tùy vào mục đích sử dụng, và quá trình này thực hiện ở runtime.&lt;/p&gt;

&lt;p&gt;Quá trình tăng stack khi cần thiết của một go routine sẽ thực hiện như sau:
- Một go routine khi init sẽ có 4KB space
- Nếu quá tải, Go runtime sẽ allocate thêm stack. Việc quản lý một function có run out of memory hay không được thực hiện bởi &lt;code&gt;prologue&lt;/code&gt;. Mỗi function đều có một prologue để quản lý bộ nhớ.&lt;/p&gt;

&lt;h1 id=&#34;goroutine-blocking&#34;&gt;Goroutine blocking&lt;/h1&gt;

&lt;p&gt;Goroutine sẽ bị block trong các trường hợp sau:
- Network
- Sleep
- Channel operations&lt;/p&gt;

&lt;p&gt;Khi một goroutine bị block, nó sẽ không khiến thread mà nó đang nằm trên bị ảnh hưởng theo.&lt;/p&gt;

&lt;p&gt;Nếu các bạn để ý, goroutines giống như một lớp abstraction của thread. Nó giúp programmer không phải làm việc trực tiếp với threads, và OS thì hầu như không biết sự tồn tại của go routine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mhqrpx4uab_Screen%20Shot%202017-03-28%20at%205.06.11%20PM.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Cái mà OS thấy chỉ đơn giản là một process ở user level xin được cấp phát và chạy multiple threads. Việc schedule goroutines trên threads tất tần tật chỉ đơn thuần là việc xây dựng một môi trường ảo ở runtime.&lt;/p&gt;

&lt;p&gt;Tất cả I/O trong Go đều là blocking. Vậy xử lý những tác vụ async như network I/O thì như thế nào?&lt;/p&gt;

&lt;p&gt;Để giải quyết vấn đề async IO thì trong Go sẽ có một phần để convert từ non-blocking sang blocking I/O. Phần này gọi là &lt;code&gt;netpoller&lt;/code&gt;. Công việc nó là nó sẽ ngồi và đợi events từ các goroutines mà muốn thực hiện network I/O, sau đó dựa vào tập file descriptor từ OS để quyết định goroutines nào sẽ được perform I/O.&lt;/p&gt;

&lt;h1 id=&#34;q-a&#34;&gt;Q&amp;amp;A&lt;/h1&gt;

&lt;p&gt;Q: Tuy context switch của goroutines rẻ, nhưng mà giờ có cả triệu goroutines thì nó cũng chậm chứ?
A: Hỏi hay đấy, nhưng go scheduler cũng giống thread scheduler. Với các OS ngày nay thì độ phức tạp của scheduling algo là O(1). Nên việc có bao nhiêu goroutines không ảnh hưởng tới context switch cost.&lt;/p&gt;

&lt;p&gt;Q: Ủa sao cái blocking goroutine mechanism của netpoller nhìn giống giống epoll/kqueue trong Unix vậy.
A: Pro ghê, cách mà goroutines được xử lý khi bị blocking khá giống với event driven trong C. Thật ra under the hood thì Go cũng sử dụng epoll/kqueue luôn. Bạn có thể đọc source Go ở &lt;a href=&#34;https://golang.org/src/runtime/netpoll.go&#34;&gt;netpoller&lt;/a&gt; để tìm hiểu thêm.&lt;/p&gt;

&lt;h1 id=&#34;nguồn&#34;&gt;Nguồn&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Analysis of the Go runtime scheduler - &lt;a href=&#34;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&#34;&gt;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Go net poller - &lt;a href=&#34;https://morsmachine.dk/netpoller&#34;&gt;https://morsmachine.dk/netpoller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Go scheduler - &lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;https://morsmachine.dk/go-scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Why Go routines stack infinite - &lt;a href=&#34;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&#34;&gt;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;How Go routines work - &lt;a href=&#34;http://blog.nindalf.com/how-goroutines-work/&#34;&gt;http://blog.nindalf.com/how-goroutines-work/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MIR - Sự tinh túy của chú cua bé nhỏ Rust</title>
      <link>https://runivn.github.io/post/rust-mir/</link>
      <pubDate>Sat, 04 Feb 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/rust-mir/</guid>
      <description>

&lt;p&gt;Dạo này Rust đang nổi lên như một thế lực khiến một hispter như mình không thể không để tâm. Sau vài ngày dig deeper vào Rust, mình cho rằng Rust là một ngôn ngữ khá hay để &amp;ldquo;học&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/cxmz5ldc6t_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Lý do:
- Rust giống C/C++, học Rust các bạn có thể giải các bài toán liên quan tới vùng nhớ- điều mà các Rubylist, Pythonist không quan tâm.
- Có ownership + borrow system để hỗ trợ memory safety.
- Traits để generic.&lt;/p&gt;

&lt;p&gt;Và đặc biệt là, Rust là một ngôn ngữ &lt;em&gt;compiler driven&lt;/em&gt;, tức là khi cái app bạn build nó không bị compiler nhả lỗi, bạn đã có một chương trình safe + performance. Suy ra cái đáng để tìm hiểu ở đây là compiler :troll:&lt;/p&gt;

&lt;p&gt;Vì vậy mình sẽ giới thiệu các bạn một chút về cái làm nên tên tuổi của và chỉ có ở Rust -  MIR.&lt;/p&gt;

&lt;p&gt;Cơ mà để hiểu được, cần có một số kiến thức căn bản.&lt;/p&gt;

&lt;h1 id=&#34;compiler-là-gì&#34;&gt;Compiler là gì&lt;/h1&gt;

&lt;p&gt;Như các bạn đã biết, mã máy(machine code) là một loại ngôn ngữ lập trình mà chỉ bao gồm hai con số 0 và 1. Với khả năng readable gần như bằng 0, ngôn ngữ máy không thể dùng phổ biến cho việc lập trình. Điều này dẫn tới việc ra đời của các ngôn ngữ cấp cao. Đặc điểm của hướng tiến hóa là càng ngày càng gần với ngôn ngữ tự nhiên. Tuy nhiên, machine code là thứ duy nhất mà CPU có thể hiểu được. Vì vậy, với mỗi loại ngôn ngữ sinh ra, đều có đi kèm song song một công cụ để biên dịch từ mã nguồn cấp cao sang mã nguồn cấp thấp có thể execute được. Đó là compiler.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7s2d1eww19_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Vậy định nghĩa compiler là gì? Là một chương trình giúp biên dịch từ một ngôn ngữ bậc cao xuống một ngôn ngữ cấp thấp(thường là machine code).
Ngược lại với compiler là decompiler, giúp dịch ngược từ một ngôn ngữ bậc thấp lên một ngôn ngữ bậc cao. Nghe giống reverse engineering? Chính xác thì decompilation chỉ là một kĩ thuật trong reverse engineering.
Ngoài ra còn có transpiler – dịch từ một ngôn ngữ bậc cao sang một ngôn ngữ bậc cao khác. Ví dụ như babel trong JS, là một trình giúp dịch từ ES6 xuống ES5.&lt;/p&gt;

&lt;h1 id=&#34;cách-hoạt-động-của-một-compiler&#34;&gt;Cách hoạt động của một compiler&lt;/h1&gt;

&lt;p&gt;Một compiler khi hoạt động sẽ có 2 phases: frontend và backend. Theo một số tài liệu thì họ chia ra thêm 1 phase là middle end nằm chính giữa nhưng theo mình thì 2 phases là đủ.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/a4x6hpr62u_blob&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Frontend compiler: Ở phase này, mã nguồn cấp cao sẽ được transform thành IR(Intermediate Representation). &lt;strong&gt;Nhớ IR này nha&lt;/strong&gt;. Các bạn tạm hiểu đây là một data structure  nằm trung gian giữa front end và backend compiler, mà được thiết kế để dễ dàng hơn trong việc optimize và translate. Một IR phải có độ chính xác tuyệt đối(có thể represent mã nguồn mà không mất thông tin). Các công việc sẽ làm ở front end bao gồm:
-   Phân tích mã nguồn, kiểm tra cú pháp và ngữ nghĩa
-   Type checking
-   Sinh ra error và warning nếu có.&lt;/p&gt;

&lt;p&gt;Backend compiler sẽ nhận vào output của front end. Công việc chính của backend sẽ là code optimization và code generation. Backend phần nhiều sẽ hỗ trợ các nền tảng(CPU) khác nhau. Các bước optimization của backend sẽ dựa trên tập lệnh của chip.
Ví dụ:
Một số chip khi thực hiện phép chia nó sẽ trả về kết quả ở một register, và số dư ở một register khác. Nên nếu trong chương trình có 2 lệnh kế nhau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c = a/b
d = a%b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&amp;gt; Backend compiler optimization sẽ hiểu điều này chỉ thực hiện một operation.&lt;/p&gt;

&lt;p&gt;Vậy output của backend compiler là gì?&lt;/p&gt;

&lt;p&gt;Backend compiler của các ngôn ngữ sẽ produce ra các loại output khác nhau. Có 3 loại output chính:
-    Assembly code.(gcc của C)
-   Bytecodes. (javac của Java, Smalltalk)
-   Machine code. (Go compiler, Rust compiler)&lt;/p&gt;

&lt;p&gt;Sở dĩ có sự khác nhau này là do cách tiếp cận của các ngôn ngữ. Ví dụ Java compiler(javac) sau khi compile xong, JVM sẽ nhận input là java bytecodes từ javac, sau đó tiến hành các bước optimization bằng JIT(Just in time compiler) và translation qua machine code(ở runtime).&lt;/p&gt;

&lt;p&gt;Còn với C, output của gcc sẽ là assembly code. Để chuyển hóa thành machine code cần thêm một utility tool gọi là assembler. (Với MS compiler thì trực tiếp build ra machine code luôn). Lí do để chỉ produce ra assembly code là để chia nhỏ công việc, dễ debug compiler. Nếu so với compilation thì việc translate từ assembly qua machine code khá đơn giản.&lt;/p&gt;

&lt;h1 id=&#34;mir-thì-có-gì-khác-biệt&#34;&gt;MIR thì có gì khác biệt?&lt;/h1&gt;

&lt;p&gt;Kiến thức cơ bản đã xong, giờ thì chúng ta sẽ đi sâu vào MIR trong Rust.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/8w0o9dboed_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Ở trên mình có giới thiệu về IR. MIR là mid-level IR, trên hình trên nó nằm giữa 2 cái là HIR - cái này thường là cây AST, và LIR hay là LLVM, cái IR magic nhất mọi thời đại. :lol:&lt;/p&gt;

&lt;p&gt;Vậy MIR trong Rust được sinh ra để làm gì?
MIR là key của các việc sau:
- Compile nhanh hơn: MIR được thiết kế để giúp compiler của Rust có thể &lt;em&gt;incremental&lt;/em&gt;. Tức là nó sẽ calculate được phần nào mới và chỉ build lại phần đó, giúp cut down được một khoản thời gian đáng kể.
- Execute nhanh hơn: Các bạn nhìn vào hình bên trái, khi mà lúc trước chỉ có một mình thằng LLVM làm nhiệm vụ optimization, thì với MIR, một số bước optimization cho riêng Rust sẽ được thực thi.
- Type checking chính xác hơn.&lt;/p&gt;

&lt;p&gt;Ở trên chỉ là những cái mà developers có thể thấy. Vậy behind the scene thì sao?&lt;/p&gt;

&lt;h1 id=&#34;behind-the-sence&#34;&gt;Behind the sence&lt;/h1&gt;

&lt;h2 id=&#34;mir-biến-rust-thành-đơn-nhân&#34;&gt;MIR biến Rust thành đơn nhân&lt;/h2&gt;

&lt;p&gt;MIR sẽ remove toàn bộ keywords &lt;code&gt;for&lt;/code&gt;,  &lt;code&gt;match&lt;/code&gt; dùng trong loop và expression, và cả method call. Sau đó thay thế bằng primitive objects.&lt;/p&gt;

&lt;p&gt;Ví dụ, một đoạn code Rust như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for elem in vec {
    process(elem);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Việc gọi &lt;code&gt;for&lt;/code&gt; chỉ đơn giản là iterator gọi next liên tục cho tới khi hết phần tử. Nên nó sẽ được viết lại như này:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut iterator = vec.into_iter();
while let Some(elem) = iterator.next() {
    process(elem);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;và cuối cùng được tranlaste bởi MIR thành:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let mut iterator = IntoIterator::into_iter(vec);

loop:
    match Iterator::next(&amp;amp;mut iterator) {
        Some(elem) =&amp;gt; { process(elem); goto loop; }
        None =&amp;gt; { goto break; }
    }

break:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vậy thì tại sao?&lt;/p&gt;

&lt;p&gt;Thứ nhất, đích đến tiếp theo của MIR sẽ là LLVM, mục tiêu là để:
- Borrow checking
- Optimize performance&lt;/p&gt;

&lt;p&gt;MIR primitive sau khi thay thế sẽ xịn hơn các construct ban đầu. Điểm đặc biệt ở đây là, &lt;code&gt;for&lt;/code&gt; và &lt;code&gt;match&lt;/code&gt; sẽ được replace thành &lt;code&gt;goto&lt;/code&gt;. Việc đưa xuống LLVM với số lượng construct càng ít sẽ được quy về các pattern càng nhỏ, dẫn đến việc optimize dễ dàng hơn.&lt;/p&gt;

&lt;p&gt;Thứ hai, cấu trúc trong MIR là type driven. Ví dụ &lt;code&gt;iterator.next()&lt;/code&gt; sẽ được desugar thành &lt;code&gt;Iterator::next(&amp;amp;mut iterator)&lt;/code&gt;.  Các bạn có thể thấy, MIR sẽ provide thêm đầy đủ trait và type information cho &lt;code&gt;interator&lt;/code&gt; để biết được hàm next() từ đâu gọi.&lt;/p&gt;

&lt;p&gt;Thứ ba, MIR làm tường minh mọi type trong Rust. Việc tường minh này giúp LLVM analyse borrow checking tốt hơn.&lt;/p&gt;

&lt;h2 id=&#34;khái-niệm-control-flow-graph&#34;&gt;Khái niệm control-flow graph.&lt;/h2&gt;

&lt;p&gt;Nhìn ở trên ta thấy MIR được translate ra dưới dạng text, nhưng thực tế bên trong compiler, MIR được biểu diễn thành một luồng điều khiển ở dạng graph, gọi tắt là CFG.&lt;/p&gt;

&lt;p&gt;Ví dụ trên sẽ được vẽ thành:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9nzjunthry_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Thực ra, bất kì compiler nào cũng đều translate ra CFG và đưa xuống cho LLVM, nhưng MIR khác ở chỗ: cái CFG mà nó translate ra match một cách hoàn hảo với cấu trúc của LLVM IR(cũng là CFG), trong khi các compiler khác không chú trọng chuyện này =&amp;gt; có thể xảy ra sự không chính xác.&lt;/p&gt;

&lt;h2 id=&#34;tối-giản-biểu-thức-match&#34;&gt;Tối giản biểu thức &lt;code&gt;match&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;MIR sẽ đơn giản hóa biểu thức &lt;code&gt;match&lt;/code&gt; ở trên thành những operations nhỏ. Cụ thể:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;match Iterator::next(&amp;amp;mut iterator) {
    Some(elem) =&amp;gt; process(elem),
    None =&amp;gt; break,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở đoạn code trên khi nó đã wrap lại 2 bước thành 1 bước, một là check xem thử có &lt;code&gt;Some&lt;/code&gt;(tức là còn elem nào không), hai là extract cái giá trị của elem đó ra(trong Rust gọi là downcasting).&lt;/p&gt;

&lt;p&gt;Khi qua MIR, nó sẽ trở thành:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop:
    // Put the value we are matching on into a temporary variable.
    let tmp = Iterator::next(&amp;amp;mut iterator);

    // Next, we &amp;quot;switch&amp;quot; on the value to determine which it has.
    switch tmp {
        Some =&amp;gt; {
            // If this is a Some, we can extract the element out
            // by &amp;quot;downcasting&amp;quot;. This effectively asserts that
            // the value `tmp` is of the Some variant.
            let elem = (tmp as Some).0;

            // The user&#39;s original code:
            process(elem);

            goto loop;
        }
        None =&amp;gt; {
            goto break;
        }
    }

break:
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Các bạn có thể thấy, &lt;code&gt;match&lt;/code&gt; đã bị replace thành &lt;code&gt;switch&lt;/code&gt; và &lt;code&gt;downcasting&lt;/code&gt;
 Tại sao lại tách ra? Lí do là vì match quá phức tạp, và mục tiêu vẫn là làm sao để LLVM có thể phát huy tối đa khả năng optimization, nên dùng switch sẽ đơn giản hơn.&lt;/p&gt;

&lt;h2 id=&#34;drops-và-panic-tường-minh&#34;&gt;Drops và Panic tường minh&lt;/h2&gt;

&lt;p&gt;Trên ví dụ trên, ta đã vô hình assume rằng mọi chuyện đều xảy ra như ý muốn. Nhưng trong thực tế thì&amp;hellip; hên xui. Đừng lo, MIR sẽ thêm thắt vào các drops(hay còn gọi là destruction) và panic operation vào trong CFG.&lt;/p&gt;

&lt;p&gt;Nó thành thế này đây
 &lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hb5e7si3o_blob&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Trên đây là overview thiết kế của MIR. Các bạn có thể thấy, MIR có ý nghĩa trong việc giảm độ phức tạp của từng câu lệnh, lại gần với LLVM IR hơn. Việc này giúp dễ phát triển các pattern cho việc optimize.&lt;/p&gt;

&lt;p&gt;Tóm lại thì, MIR được Rust đầu tư với hi vọng trở thành một ngọn cờ đầu của compiler evolution, khi mà tất cả các lý thuyết của nó đều quá hoàn hảo. Mục tiêu ban đầu của MIR là sẽ ôm xô một số công việc từ HIR và LLVM.&lt;/p&gt;

&lt;p&gt;MIR sắp ra đời rồi, mọi người đón chờ xem nhé :laclac:&lt;/p&gt;

&lt;p&gt;Nguồn tham khảo: &lt;a href=&#34;https://blog.rust-lang.org/2016/04/19/MIR.html&#34;&gt;https://blog.rust-lang.org/2016/04/19/MIR.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Viết một facebook messenger bot đơn giản cùng Go &#43; ngrok</title>
      <link>https://runivn.github.io/post/go-facebook-bot/</link>
      <pubDate>Thu, 18 Aug 2016 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-facebook-bot/</guid>
      <description>

&lt;p&gt;Messenger bots của facebook ra cũng khá lâu rồi. Đã có nhiều người sử dụng cho page facebook của mình. Bài này của mình sẽ hướng dẫn các bạn viết 1 con bot tự động trả lời theo pattern có sẵn bằng Go - cho server và ngrok - để publish localhost ra ngoài.&lt;/p&gt;

&lt;p&gt;Kiểu này:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%201.43.47%20PM.png_tigvw7dimg&#34; class=&#34;img-center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Những thứ bạn cần có:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Một page facebook&lt;/li&gt;
&lt;li&gt;Nhiêu đủ rồi&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;facebook-stuffs&#34;&gt;Facebook stuffs&lt;/h1&gt;

&lt;p&gt;Đầu tiên bạn vào &lt;a href=&#34;https://developers.facebook.com&#34;&gt;https://developers.facebook.com&lt;/a&gt; và chọn app của mình.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%201.49.49%20PM.png_bectpu8v2e&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Ở tab bên trái các bạn &lt;code&gt;Add Product&lt;/code&gt;. Chọn &lt;code&gt;Webhooks&lt;/code&gt;, và &lt;code&gt;New Subscription&lt;/code&gt; và chọn &lt;code&gt;Page&lt;/code&gt; ở dropdown. Sẽ hiện ra cái popup như này:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%201.51.56%20PM.png_4suocqh1zi&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Ở đây mình chỉ chọn subscription field là &lt;code&gt;messages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Để có thể lưu cái subscription này lại, bạn cần một &lt;code&gt;Callback URL&lt;/code&gt; và một &lt;code&gt;Verify token&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Callback URL là nơi mà messenger sẽ gửi data khi nhận được message trên page của facebook.
Ở đây mình sẽ sử dụng Go làm server, chạy trên localhost. Sau đó dùng ngrok publish ra một https URL(vì Callback URL facebook chỉ nhận https)&lt;/p&gt;

&lt;p&gt;Verify token thì bạn điền token mà mình muốn verify lại 1 lần nữa(sử dụng trong Go server để double check)&lt;/p&gt;

&lt;p&gt;Ta da! Để cái popup này lại đấy, chuyển sang viết server.&lt;/p&gt;

&lt;h1 id=&#34;go-server&#34;&gt;Go server&lt;/h1&gt;

&lt;p&gt;Tạo 1 file &lt;code&gt;main.go&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Viết hàm main cho nó, làm nhiệm vụ là serve ở port 8085 một cái webhook.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	http.HandleFunc(&amp;quot;/webhook&amp;quot;, webhookHandler)
	http.ListenAndServe(&amp;quot;:8085&amp;quot;, nil)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Viết hàm &lt;code&gt;webhookHandler&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func webhookHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == &amp;quot;GET&amp;quot; {
		verifyTokenAction(w, r)
	}
	if r.Method == &amp;quot;POST&amp;quot; {
		webhookPostAction(w, r)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tại sao lại có 2 hàm GET và POST ở đây? GET sẽ được gọi khi bạn bấm nút &lt;code&gt;Verify and Save&lt;/code&gt; ở popup phía trên. Còn POST sẽ được gọi khi có ai đó nhắn tin trên facebook page. Với GET thì mình chỉ check xem có gửi đúng &lt;code&gt;verifyToken&lt;/code&gt; không, và log ra thôi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func verifyTokenAction(w http.ResponseWriter, r *http.Request) {
	if r.URL.Query().Get(&amp;quot;hub.verify_token&amp;quot;) == verifyToken {
		log.Print(&amp;quot;verify token success.&amp;quot;)
		fmt.Fprintf(w, r.URL.Query().Get(&amp;quot;hub.challenge&amp;quot;))
	} else {
		log.Print(&amp;quot;Error: verify token failed.&amp;quot;)
		fmt.Fprintf(w, &amp;quot;Error, wrong validation token&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quan trọng là xử lý hàm POST:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func webhookPostAction(w http.ResponseWriter, r *http.Request) {
	var receivedMessage ReceivedMessage
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Print(err)
	}
	if err = json.Unmarshal(body, &amp;amp;receivedMessage); err != nil {
		log.Print(err)
	}
	messagingEvents := receivedMessage.Entry[0].Messaging
	for _, event := range messagingEvents {
		senderID := event.Sender.ID
		if &amp;amp;event.Message != nil &amp;amp;&amp;amp; event.Message.Text != &amp;quot;&amp;quot; {
			message := getReplyMessage(event.Message.Text)
			sendTextMessage(senderID, message)
		}
	}
	fmt.Fprintf(w, &amp;quot;Success&amp;quot;)
}
func getReplyMessage(receivedMessage string) string {
	var message string
	receivedMessage = strings.ToUpper(receivedMessage)
	log.Print(&amp;quot; Received message: &amp;quot; + receivedMessage)

    if strings.Contains(receivedMessage, &amp;quot;HELLO&amp;quot;) {
		message = &amp;quot;Hi, my name is Annie. Nice to meet you&amp;quot;
	}

	return message
}

func sendTextMessage(senderID string, text string) {
	recipient := new(Recipient)
	recipient.ID = senderID
	sendMessage := new(SendMessage)
	sendMessage.Recipient = *recipient
	sendMessage.Message.Text = text
	sendMessageBody, err := json.Marshal(sendMessage)
	if err != nil {
		log.Print(err)
	}
	req, err := http.NewRequest(&amp;quot;POST&amp;quot;, FacebookEndPoint, bytes.NewBuffer(sendMessageBody))
	if err != nil {
		log.Print(err)
	}
	fmt.Println(&amp;quot;%T&amp;quot;, req)
	fmt.Println(&amp;quot;%T&amp;quot;, err)

	values := url.Values{}
	values.Add(&amp;quot;access_token&amp;quot;, accessToken)
	req.URL.RawQuery = values.Encode()
	req.Header.Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json; charset=UTF-8&amp;quot;)
	client := &amp;amp;http.Client{Timeout: time.Duration(30 * time.Second)}
	res, err := client.Do(req)
	if err != nil {
		log.Print(err)
	}
	defer res.Body.Close()
	var result map[string]interface{}
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Print(err)
	}
	if err := json.Unmarshal(body, &amp;amp;result); err != nil {
		log.Print(err)
	}
	log.Print(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hàm trên có 2 hàm:
- &lt;code&gt;getReplyMessage&lt;/code&gt;: Ở đây mình chỉ xem thử nếu có chữ hello thì mình sẽ trả về message greeting tương ứng. Các bạn có thể sử dụng các kĩ thuật khác cao cấp hơn.
- &lt;code&gt;sendTextMessage&lt;/code&gt;: Hàm này sẽ gửi về POST request về facebook endpoint, sau đó facebook sẽ gửi tin nhắn tới người nhận(người vừa mới chat trên page facebook).&lt;/p&gt;

&lt;p&gt;Chạy server lên bằng &lt;code&gt;go run main.go&lt;/code&gt;. Ta được một server đang chạy ở port 8085&lt;/p&gt;

&lt;h1 id=&#34;ngrok&#34;&gt;Ngrok&lt;/h1&gt;

&lt;p&gt;Các bạn tải ngrok về ở đây &lt;a href=&#34;https://ngrok.com/&#34;&gt;https://ngrok.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chạy ngrok:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngrok http 8085
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sẽ được như này:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%202.39.47%20PM.png_95j7zf1bgb&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;localhost:8085&lt;/code&gt; đã được ngrok chuyển thành &lt;code&gt;https&lt;/code&gt; và publish ra bên ngoài.&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;Config&lt;/h1&gt;

&lt;p&gt;Mọi thứ gần như đã xong. Các bạn chỉ cần paste callback URL đã được forward bởi ngrok vào popup của facebook lúc nãy, điền verify token là xong rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%202.43.19%20PM.png_oe8usmiac8&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Như vậy là các bạn có thể pm facebook page chat thử và chờ response.&lt;/p&gt;

&lt;h1 id=&#34;kết&#34;&gt;Kết&lt;/h1&gt;

&lt;p&gt;Trên này là một sample đơn giản. Facebook messenger bots có rất nhiều tiềm năng trong lĩnh vực bán hàng hay trả lời tự động. Các bạn nào chưa nghịch thì có thể nghịch thử.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dùng selenium để crawl dữ liệu(Go lang)</title>
      <link>https://runivn.github.io/post/go-selenium/</link>
      <pubDate>Fri, 26 Feb 2016 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-selenium/</guid>
      <description>

&lt;h2 id=&#34;crawl-dữ-liệu&#34;&gt;Crawl dữ liệu&lt;/h2&gt;

&lt;p&gt;Crawl là một vấn đề hay gặp trong quá trình làm software. Ví dụ lấy tin tức, tin giảm giá, vé xem phim&amp;hellip; là những dạng của crawl. Một cách khá đơn giản đó là phân tích HTML, đọc các thẻ và rút trích dữ liệu. Thư viện trên Go mình hay dùng đó là &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;goquery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tuy nhiên việc crawl một trang bằng đọc HTML thuần sẽ không work được trong một số trường hợp như: dữ liệu được load bằng ajax(lúc đọc HTML sẽ chỉ thấy wrapper chứ không thấy dữ liệu) hay muốn vào được trang cần crawl thì phải qua bước login,&amp;hellip;&lt;/p&gt;

&lt;p&gt;Trong bài này mình sẽ lấy một ví dụ, mình muốn crawl lấy những giảm giá của amazon: &lt;a href=&#34;http://www.amazon.com/gp/goldbox/all-deals/ref=gbps_ftr_s-3_3022_wht_541966?ie=UTF8&amp;amp;*Version*=1&amp;amp;*entries*=0&amp;amp;gb_f_GB-SUPPLE=sortOrder:BY_SCORE,enforcedCategories:3760911%252C2335752011%252C541966&amp;amp;pf_rd_p=2292853022&amp;amp;pf_rd_s=slot-3&amp;amp;pf_rd_t=701&amp;amp;pf_rd_i=gb_all&amp;amp;pf_rd_m=ATVPDKIKX0DER&amp;amp;pf_rd_r=14CQSB5TF4GTC2RNHDAG&#34;&gt;amazon deal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Trang này javasript sẽ gọi ajax lấy dữ liệu và sau đó mới đổ vào cây DOM. Khi dùng goquery đọc HTML thì sẽ không thấy được các thẻ div như khi inspect element.&lt;/p&gt;

&lt;p&gt;Với những loại như thế này, mình sử dụng selenium để chạy web trên browser thật, thực hiện thao tác để được trang HTML fully load rồi mới trích xuất dữ liệu.&lt;/p&gt;

&lt;p&gt;Selenium chạy trên nền JVM, khá nổi tiếng trong lĩnh vực automation test. Nó cho phép mình chạy script test trên browser thật.
Cách làm của mình sẽ là: Dùng selenium chạy trang amazon lên, đợi javascript load xong và sau đó crawl dữ liệu bình thường.&lt;/p&gt;

&lt;h2 id=&#34;cách-cài-đặt&#34;&gt;Cách cài đặt&lt;/h2&gt;

&lt;p&gt;Đầu tiên các bạn vào link của &lt;a href=&#34;http://docs.seleniumhq.org/download/&#34;&gt;seleniumhq&lt;/a&gt; để tải và cài đặt seleniumhq. Seneliumhq đóng vai trò như là một server, sẽ nhận các request được gửi từ code Go của mình.&lt;/p&gt;

&lt;p&gt;Để chạy, chúng ta vào thư mục chứa file jar và chạy câu lệnh:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -jar selenium-server-standalone-2.50.1.jar -port 8081&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-02-26%20at%203.57.22%20PM.png_uka1cbcuxl&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;=&amp;gt;&amp;gt; Chúng ta được một server selenium chạy ở port 8081.&lt;/p&gt;

&lt;p&gt;Tiếp theo các bạn kéo goselenium về bằng go get:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go get sourcegraph.com/github.com/sourcegraph/go-selenium&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Việc kế tiếp là cài đặt browser, mình chọn Firefox. Các bạn lưu ý, khi chạy trên local thì chỉ cần cài đặt Firefox trên web là được. Còn khi setup trên host thì các bạn cần cài đặt firefox bằng shell script. Các bạn có thể tham khảo &lt;a href=&#34;https://gist.github.com/curtismcmullan/7be1a8c1c841a9d8db2c&#34;&gt;cách setup selenium trên Ubuntu 14.04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Setup đã xong! Giờ vào code Go thôi.&lt;/p&gt;

&lt;p&gt;Chúng ta cần:
- Remote vào server selenium
- Truy xuất tới đường dẫn amazon deal
- Tiến hành phân tích HTML để lấy thông tin, mình sẽ in ra thông tin page title và image sản phẩm đầu tiên.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var webDriver selenium.WebDriver
	var err error
    // set browser as firefox
	caps := selenium.Capabilities(map[string]interface{}{&amp;quot;browserName&amp;quot;: &amp;quot;firefox&amp;quot;})
    // remote to selenium server
	if webDriver, err = selenium.NewRemote(caps, &amp;quot;http://localhost:8081/wd/hub&amp;quot;); err != nil {
		fmt.Printf(&amp;quot;Failed to open session: %s\n&amp;quot;, err)
		return
	}
	defer webDriver.Quit()

	err = webDriver.Get(URL_AMAZON_DEAL)
	if err != nil {
		fmt.Printf(&amp;quot;Failed to load page: %s\n&amp;quot;, err)
		return
	}
	// sleep for a while for fully loaded javascript
	time.Sleep(4 * time.Second)
	// get title
	if title, err := webDriver.Title(); err == nil {
		fmt.Printf(&amp;quot;Page title: %s\n&amp;quot;, title)
	} else {
		fmt.Printf(&amp;quot;Failed to get page title: %s&amp;quot;, err)
		return
	}

	var elem selenium.WebElement
	elem, err = webDriver.FindElement(selenium.ByCSSSelector, &amp;quot;#widgetContent&amp;quot;)
	if err != nil {
		fmt.Printf(&amp;quot;Failed to find element: %s\n&amp;quot;, err)
		return
	}

	var firstElem selenium.WebElement
	firstElem, err = elem.FindElement(selenium.ByCSSSelector, &amp;quot;.a-section .dealContainer&amp;quot;)
	if err != nil {
		fmt.Printf(&amp;quot;Failed to find element: %s\n&amp;quot;, err)
		return
	}
    // get image
	image, err := firstElem.FindElement(selenium.ByCSSSelector, &amp;quot;img&amp;quot;)
	if err == nil {
		img, _ := image.GetAttribute(&amp;quot;src&amp;quot;)
		fmt.Println(img)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy code lên chúng ta được&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Page title: Gold Box Deals | Today&#39;s Deals - Amazon.com
https://images-na.ssl-images-amazon.com/images/I/51eU5JrGAXL._AA210_.jpg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã lấy được thông tin cần lấy.&lt;/p&gt;

&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được khi gặp vấn đề về crawl trong quá trình software development, ở đây là ngôn ngữ Go.
Selenium có thể giúp chúng ta trong nhiều trường hợp khác, ví dụ những trang web cần đăng nhập, các trang web có captcha&amp;hellip;
Nếu ai có kinh nghiệm gì khác, mong các bạn đóng góp thêm.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn sử dụng Vim để code Go</title>
      <link>https://runivn.github.io/post/vim-go/</link>
      <pubDate>Fri, 04 Sep 2015 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/vim-go/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Vim là một text-editor khá mạnh, được sử dụng trong môi trường máy chủ không có giao diện đồ họa. Trong bài này mình sẽ giới thiệu Vim căn bản và hướng dẫn các bạn sử dụng Vim như một IDE dành cho Go&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vim-là-gì&#34;&gt;Vim là gì?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vim là text editor cao cấp, phiên bản sau của Vi(Vim = Vi Improved), được viết bởi Bram Moolenaar, lần đầu tiên được đưa ra vào năm 1991.&lt;/li&gt;
&lt;li&gt;Vim thường được gọi à &amp;ldquo;editor dành cho dân lập trình&amp;rdquo;, tuy nhiên nó có thể hầu hết các công việc liên quan tới văn bản như sửa chữa văn bản, soạn thảo email hay sửa file configs.&lt;/li&gt;
&lt;li&gt;Vim có thể sử dụng làm IDE nhờ các plugins&lt;/li&gt;
&lt;li&gt;Vim hỗ trợ đa nền tảng.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cài-đặt-và-config&#34;&gt;Cài đặt và config&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vim có thể được download tại trang &lt;a href=&#34;http://www.vim.org/download.php&#34;&gt;vim homepage&lt;/a&gt; hoặc cài đặt bằng &lt;a href=&#34;http://brew.sh/&#34;&gt;brew&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     brew install vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vì một số plugins phía sau có thể cần tới lua nên các bạn nên cài với câu lệnh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     brew install vim --with-lua
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau khi cài đặt xong, các bạn tạo một file .vimrc ở ~/ (file này không tự động tạo). File .vimrc này sẽ là nơi chứa toàn bộ config, plugins hay bundle cũng như các function liên quan tới vim.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tiếp theo là cài vim plugins manager. Hiện tại mình đang sử dụng &lt;a href=&#34;https://github.com/VundleVim/Vundle.vim&#34;&gt;Vundle&lt;/a&gt;, các bạn có thể sử dụng &lt;a href=&#34;https://github.com/tpope/vim-pathogen&#34;&gt;panthogen&lt;/a&gt; nếu thích.
Vundle sẽ giúp các bạn trong việc config các plugins trong .vimrc, install hay update và một số việc khác.
Để cài đặt, các bạn clone vundle vào thư mục ~/.vim/bundle/ (thư mục .vim sẽ có sau khi cài đặt vim xong)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy vào .vimrc một số configs và các plugin cơ bản (chú ý dấu &amp;ldquo; trong vim là comment)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible              &amp;quot; be iMproved, required
filetype off                  &amp;quot; required

&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&#39;~/some/path/here&#39;)

&amp;quot; let Vundle manage Vundle, required
Plugin &#39;VundleVim/Vundle.vim&#39;

&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
Plugin &#39;tpope/vim-fugitive&#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
Plugin &#39;L9&#39;
&amp;quot; Git plugin not hosted on GitHub
Plugin &#39;git://git.wincent.com/command-t.git&#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
Plugin &#39;file:///home/gmarik/path/to/plugin&#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
Plugin &#39;rstacruz/sparkup&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}
&amp;quot; Avoid a name conflict with L9
Plugin &#39;user/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}

&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiếp theo để install plugins, các bạn mở vim lên và chạy command sau(bằng cách nhấn Esc):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :PluginInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để update plugins, các bạn sử dụng&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :PluginUpdate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy là đủ đồ chơi để các bạn có thể sử dụng Vim rồi.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hướng-dẫn-sử-dụng-căn-bản&#34;&gt;Hướng dẫn sử dụng căn bản.&lt;/h2&gt;

&lt;p&gt;Vim là một chương trình soạn thảo được build lần đầu tiên trên UNIX, dùng để làm việc trên môi trường ko có UI. Lúc này bàn phím chưa cũng khá thô sơ, nên các bước di chuyển trên vim hơi khác với bình thường:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vimsheet.com/images/hjkl.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Các bạn có thể tự tập luyện việc sử dụng các phím này bằng &lt;a href=&#34;http://vim-adventures.com/&#34;&gt;vim game&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Để mở một file với vim, các bạn dùng câu lệnh:
        &lt;code&gt;vim file_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Trong vim có 3 mode:
 &amp;ndash; Normal mode - xuất hiện khi bạn ấn Ecs, thường đi kèm đầu tiên bởi dấu &amp;ldquo;:&amp;ldquo;. Ở đây vim sẽ hiểu những gì bạn gõ vào là câu lệnh cho vim. Ví dụ:&lt;code&gt;:w&lt;/code&gt; là save văn bản, &lt;code&gt;:q&lt;/code&gt; là thoát một văn bản.
       Vim có ngôn ngữ riêng dành cho mình, đó là Vim script. Vim script có thể được execute ở normal mode, ví dụ, để in ra Hello world chúng ta dùng:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :echo &amp;quot;Hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; Insert mode - xuất hiện khi bạn nhấn một trong các nút sau :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      a: Insert vào phía sau con trỏ hiện tại
      A: Insert vào cuối hàng
      i: Insert vào phía trước con trỏ hiện tại
      I: Insert vào đầu hàng
      o: Insert và mở một hàng trống phía dưới
      O: Insert và mở một hàng trống phía trên
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; Visual mode &amp;ndash; xuất hiện khi bạn ấn nút v, được dùng cho việc chọn một mảng block text lớn, có thể sử dụng vào việc copy paste hoặc comment&amp;hellip;&lt;/p&gt;

&lt;p&gt;Các bạn có thể đọc &lt;a href=&#34;http://bullium.com/support/vim.html&#34;&gt;vim command&lt;/a&gt; để biết thêm về các command trong vim.&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-vim-như-go-ide&#34;&gt;Sử dụng Vim như Go IDE&lt;/h2&gt;

&lt;p&gt;Để sử dụng Vim như một IDE cho Go, chúng ta cần cài đặt một số plugins cho go.&lt;/p&gt;

&lt;p&gt;Quan trọng nhất là &lt;a href=&#34;https://github.com/fatih/vim-go/&#34;&gt;vim go&lt;/a&gt;. Vim go bao gồm tập hợp các thư viện hỗ trợ Go cho vim, ví dụ &lt;code&gt;godef&lt;/code&gt;
   &lt;code&gt;gofmt&lt;/code&gt; &lt;code&gt;go test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Để cài đặt vim go, các bạn copy plugin vào file .vimrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Plugin &#39;fatih/vim-go&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau đó vào normal mode bằng cách nhấn &lt;code&gt;Esc&lt;/code&gt; và gõ command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   :PluginInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xong, lại tiếp tục gõ command để install Go binaries&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :GoInstallBinaries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chỉ với Vim-go các bạn đã có thể code Go được rồi, nhưng để mọi thứ dễ nhìn hơn cũng như tăng độ hiệu quả, các bạn nên tìm và cài thêm các plugin sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ack.vim
    bclose.vim
    bufexplorer
    nerdtree
    nerdcommenter
    csapprox
    vim-fugitive
    gitv
    vim-gitgutter
    syntastic
    neocomplete.vim
    neosnippet.vim
    auto-pairs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong số này:&lt;/p&gt;

&lt;p&gt;&amp;ndash; nerdtree: Giúp bạn tổ chức folder trong vim dưới dạng cây thư mục, dễ dàng hơn trong việc mở file và folder. Sau khi cài đặt:&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>