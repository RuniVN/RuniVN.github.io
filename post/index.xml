<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Runi blog</title>
    <link>https://runivn.github.io/post/index.xml</link>
    <description>Recent content in Posts on Runi blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 May 2018 16:45:32 +0700</lastBuildDate>
    <atom:link href="https://runivn.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bảo mật 2 lớp và ứng dụng (Go code demo)</title>
      <link>https://runivn.github.io/post/2fa/</link>
      <pubDate>Fri, 25 May 2018 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/2fa/</guid>
      <description>

&lt;p&gt;Trong thế giới của việc thông tin cá nhân đang ngày càng bị xâm phạm và tấn công, đến thời điểm này đã có gần &lt;a href=&#34;https://breachlevelindex.com/&#34;&gt;10 tỷ&lt;/a&gt; accounts bị leaked thì chuyện phải implement một phương pháp đăng nhập có tính bảo mật cao hơn là một chuyện bất cứ cá nhân/tổ chức nào cũng aware được.&lt;/p&gt;

&lt;p&gt;Two-factor Authentication là một trong số đó. Trong bài này mình sẽ chia sẻ những kiến thức đã tổng hợp được trong quá trình làm việc với 2FA.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7gklibkwls_image.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;two-factor-authentication-2fa-là-gì&#34;&gt;Two-Factor Authentication (2FA) là gì?&lt;/h2&gt;

&lt;p&gt;Two-Factor Authentication (2FA) hay còn gọi là Bảo mật 2 lớp, là một phương thức để chứng thực user bằng việc combine 2 factors khác nhau từ bộ source:
- Một cái gì đó bạn biết.
- Một cái gì đó bạn có.
- Một cái gì đó mà nó mặc nhiên như vậy.&lt;/p&gt;

&lt;p&gt;Một ví dụ khá cơ bản của 2FA đó là khi bạn rút tiền ở ATM, bạn cần 2 thứ, một là cái thẻ (bạn có) và mã PIN (bạn biết) mới có khả năng thực hiện rút tiền.&lt;/p&gt;

&lt;p&gt;Như vậy nó áp dụng trong online authentication như thế nào?&lt;/p&gt;

&lt;p&gt;Với bảo mật thông thường, bạn chỉ cần nhập username và password để đăng nhập tài khoản của mình, thứ bảo vệ duy nhất của bạn là mật khẩu. Đây là cái mà &amp;ldquo;bạn biết&amp;rdquo;. 2FA sẽ thêm một extra layer để bạn cần provide cái mà &amp;ldquo;bạn có&amp;rdquo; nữa.&lt;/p&gt;

&lt;h2 id=&#34;các-loại-2fa&#34;&gt;Các loại 2FA&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hardware Token&lt;/li&gt;
&lt;li&gt;SMS/Voice based&lt;/li&gt;
&lt;li&gt;Software Token&lt;/li&gt;
&lt;li&gt;Push notification&lt;/li&gt;
&lt;li&gt;Các loại khác&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Như bạn thấy, có rất nhiều cách để mô phỏng cái mà &amp;ldquo;bạn có&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Chẳng hạn, SMS là một sự lựa chọn không tồi, server gửi SMS về cho user để đăng nhập. Nhưng SMS lại ko quá an toàn (có thể bị intercepted), và bị vấn đề về network, việc delay có thể làm ảnh hưởng tới authentication process.&lt;/p&gt;

&lt;p&gt;Vì nhiều lí do khác nhau nên team quyết định chọn dùng Software Token cho 2FA. Và từ bây giờ trong bài viết mình 2FA cũng được ám chỉ tới phương pháp sử dụng cryptographically key của Software Token.&lt;/p&gt;

&lt;h2 id=&#34;2fa-hoạt-động-như-thế-nào&#34;&gt;2FA hoạt động như thế nào?&lt;/h2&gt;

&lt;p&gt;Mình lấy ví dụ gitlab.
Đây là lúc đăng nhập, mình sẽ provide user và password.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/qg21xb61c9_Screen%20Shot%202018-05-25%20at%203.15.24%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sau khi đăng nhập xong, vì mình có enable 2FA nên nó sẽ redirect mình tới trang điền code (soft token).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/wi0hndhayn_Screen%20Shot%202018-05-25%20at%203.15.33%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Code này sẽ được lấy từ Authentication application, có thể là Authy, Google authenticator &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mui8qfsb9c_Screen%20Shot%202018-05-25%20at%204.43.50%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ví dụ như mình dùng Authy để lấy được code. Mỗi code sẽ được thay đổi sau 30s.&lt;/p&gt;

&lt;p&gt;Với code này mình sẽ đăng nhập thành công.&lt;/p&gt;

&lt;h2 id=&#34;cơ-chế-hoạt-động-internally-của-2fa&#34;&gt;Cơ chế hoạt động internally của 2FA&lt;/h2&gt;

&lt;p&gt;Khi bạn enable 2FA cho tài khoản của mình, bạn sẽ nhận được một secret key based 32. Tùy vào mức độ security, độ dài của secret key có thể là 80, 128 hoặc 160 bit.&lt;/p&gt;

&lt;p&gt;Các authenticator application sẽ scan secret này dưới dạng QR code (hoặc manually) và dùng nó để generate ra một HMAC-SHA1. Chuỗi HMAC này có thể là một trong 2 dạng:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm&#34;&gt;TOTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_algorithm&#34;&gt;HOTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sau đó HMAC này sẽ được extracted và lấy ra 1 số int 4 byte, đó chính là code.&lt;/p&gt;

&lt;p&gt;Một mã code sẽ valid trong 30 giây. Tuy nhiên không phải ai cũng có clock synced giống nhau, vì network latency các kiểu nên thường mọi người hay cho phép ở phạm vi cộng trừ 1 code, tức là 1 code sẽ valid trong 1 phút 30 giây. Điều này có thể giảm tính an toàn, nhưng lại tăng sự trải nghiệm đáng kể.&lt;/p&gt;

&lt;h3 id=&#34;backup-codes&#34;&gt;Backup codes&lt;/h3&gt;

&lt;p&gt;Backup codes hay recovery codes sẽ được sử dụng trong trường hợp bạn không thể sử dụng điện thoại, bạn có thể dùng chúng để đăng nhập. Có 2 loại backup codes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multiple backup codes: Ví dụ github sẽ cho bạn 10 codes, và mỗi code sẽ được sử dụng 1 lần.&lt;/li&gt;
&lt;li&gt;Single backup code: Bạn dùng cái code này đồng nghĩa với việc bạn có thể đăng nhập, nhưng phải setup lại 2FA (nó assume bạn bị mất điện thoại).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;làm-thế-nào-để-apply-2fa-vào-dự-án-của-mình&#34;&gt;Làm thế nào để apply 2FA vào dự án của mình?&lt;/h2&gt;

&lt;p&gt;Khá đơn giản, hầu hết ngôn ngữ đều open source implementation của mình. Mình code Go, library mà mình chọn là &lt;code&gt;github.com/dgryski/dgoogauth&lt;/code&gt; được viết bởi Damian Gryski, một gopher rất nổi tiếng.&lt;/p&gt;

&lt;p&gt;Flow chương trình
&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hnxlni0dqr_Screen%20Shot%202018-05-25%20at%206.07.49%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Khi một user muốn enable 2FA, App sẽ gọi &lt;code&gt;RequestGenerate2FA&lt;/code&gt; API.&lt;/p&gt;

&lt;p&gt;Trong API này sẽ generate ra một temporary secret và lưu vào redis, trong thời gian expire 5 phút.&lt;/p&gt;

&lt;p&gt;GenerateSecret thì khá đơn giản thôi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// GenerateSecret generates a 10 byte secret string.
func GenerateSecret() (string, error) {
	random := make([]byte, 10)
	_, err := rand.Read(random)
	if err != nil {
		return &amp;quot;&amp;quot;, err
	}
	return base32.StdEncoding.EncodeToString(random), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau khi app nhận được secret, sẽ turn thành QR code và đưa cho user. QR code này sẽ được user dùng Authenticator application để quét.&lt;/p&gt;

&lt;p&gt;Khi đã có code, user input vào và app sẽ tiếp tục make request lên API &lt;code&gt;Generate2FA&lt;/code&gt;. Nếu thành công thì user đã được enable 2FA.&lt;/p&gt;

&lt;p&gt;Trong hàm &lt;code&gt;Generate2FA&lt;/code&gt; chúng ta cần verify được code gửi lên và secret lấy từ redis có valid hay không. Sử dụng library trên như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;otpc := &amp;amp;dgoogauth.OTPConfig{
      Secret:      info.Secret,
      WindowSize:  3,
      HotpCounter: 0,
}

valid, err := otpc.Authenticate(req.Code)
if err != nil || !valid {
	return errors.New(&amp;quot;Invalid authenticate code&amp;quot;)
}

// success validation

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Các bạn có thể đọc thêm source code để biết function Authenticate hoạt động như thế nào, chỉ có 1 file thôi, rất đơn giản).&lt;/p&gt;

&lt;p&gt;Sau khi validate xong thì mình trả về Recovery codes luôn (cho tiện ở phía application).&lt;/p&gt;

&lt;p&gt;Còn đây thì flow khi login, nếu cần thêm 2FA thì sẽ require code từ user, sau đó upgrade cái access token đó (simply add thêm 1 fields &lt;code&gt;2fa: true&lt;/code&gt;) để nhận dạng là đã 2FA authenticated rồi.
&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gvri4aj6di_Screen%20Shot%202018-05-25%20at%206.11.36%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận&lt;/h2&gt;

&lt;p&gt;2FA là một kĩ thuật dùng để enhance security layer của một application. Hay nói cách khác, bạn khóa 1 cửa bằng 2 cái khóa luôn an toàn hơn 1 cái. Trong xã hội đầy loạn lạc này thì ứng dụng nào quan trọng, chứa nhiều sensitive data và liên quan tới tiền bạc thì cứ auto bật 2FA thôi.&lt;/p&gt;

&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.gosquared.com/building-two-factor-authentication&#34;&gt;https://engineering.gosquared.com/building-two-factor-authentication&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://authy.com/what-is-2fa/&#34;&gt;https://authy.com/what-is-2fa/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Lib hay mỗi tuần] Goconvey - Thay đổi cách test của bạn</title>
      <link>https://runivn.github.io/post/go-convey/</link>
      <pubDate>Fri, 01 Dec 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-convey/</guid>
      <description>

&lt;p&gt;Lần này mình sẽ review về một Go lib hay ho - &lt;a href=&#34;https://github.com/smartystreets/goconvey&#34;&gt;GoConvey&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;Một fancy testing tool cho Gophers. Có hỗ trợ Browser UI và một vài concept theo mình là khá hay.&lt;/p&gt;

&lt;h2 id=&#34;một-số-đặc-điểm&#34;&gt;Một số đặc điểm&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Behavioral test&lt;/li&gt;
&lt;li&gt;Browser UI integration (cho cả go test native)&lt;/li&gt;
&lt;li&gt;Output rất đẹp mắt :))&lt;/li&gt;
&lt;li&gt;Concept về execution order thú vị giúp setup + teardown một cách tự nhiên&lt;/li&gt;
&lt;li&gt;Isolated test cases&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cách-cài-đặt&#34;&gt;Cách cài đặt&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;go get github.com/smartystreets/goconvey&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;cách-sử-dụng&#34;&gt;Cách sử dụng&lt;/h2&gt;

&lt;p&gt;Giờ mình sẽ có vài cái hàm đơn giản như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func Add(a, b int) int {
	return a + b
}

func Subtract(a, b int) int {
	return a - b
}

func Multiply(a, b int) int {
	return a * b
}

func Division(a, b int) (int, error) {
	if b == 0 {
		return 0, errors.New(&amp;quot;can not divide by zero&amp;quot;)
	}
	return a / b, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Giờ test nó bằng Covey xem sao.&lt;/p&gt;

&lt;p&gt;Để sử dụng thì các bạn import &lt;code&gt;. &amp;quot;github.com/smartystreets/goconvey/convey&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dấu &amp;ldquo;.&amp;rdquo; ở đây cho phép được dùng thẳng function trong convey luôn mà không cần gọi thông qua identifier (gọi thẳng Convey thay vì convey.Convey). Code sẽ nhìn clear hơn.&lt;/p&gt;

&lt;p&gt;Test thử hàm Add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestAdd(t *testing.T) {
	Convey(&amp;quot;Add two numbers&amp;quot;, t, func() {
		So(Add(1, 2), ShouldEqual, 3)
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một function test sẽ bắt đầu bằng từ khóa &lt;code&gt;Convey&lt;/code&gt;. Ở trên hàm TestAdd sẽ thử  dùng hàm Add cộng 2 số 1 và 2 và test xem thử có đúng bằng 3 không.
Việc assert ở đây là thông qua từ khóa &lt;code&gt;So&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Các bạn có thể thấy giống như viết văn vậy: &lt;em&gt;So Add(1,2) should equal 3&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Viết thử hàm khó hơn xem. Hàm chia. Hàm chia thì mình cần phải xét thêm 1 điều kiện là chia cho 0. Hàm test của chúng ta có nội dung như sau.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestDivision(t *testing.T) {
	Convey(&amp;quot;Divide one by another&amp;quot;, t, func() {

		Convey(&amp;quot;Divide by non-zero number&amp;quot;, func() {
			num, err := Division(10, 2)
			So(err, ShouldBeNil)
			So(num, ShouldEqual, 5)
		})

		Convey(&amp;quot;Divide by zero&amp;quot;, func() {
			_, err := Division(10, 0)
			So(err, ShouldNotBeNil)
		})
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dễ hiểu quá đúng không?&lt;/p&gt;

&lt;p&gt;Khi chạy chúng ta chạy bằng lệnh go test builtin của go. Kết quả sẽ được:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/c92bb2v76j_Screen%20Shot%202017-11-30%20at%2010.57.10%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Với mỗi &lt;code&gt;So&lt;/code&gt; pass chúng ta sẽ được 1 dấu tick. Khi bạn viết assert nhiều value thì sẽ ra nhiều dấu tick rất đẹp mắt. &lt;code&gt;So&lt;/code&gt; fail thì sẽ ra dấu &lt;code&gt;X&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Goconvey ngoài ra còn giúp chúng ta visualize testcases thông qua web portal.&lt;/p&gt;

&lt;p&gt;Các bạn chạy command &lt;code&gt;goconvey&lt;/code&gt;. Nó sẽ đưa các bạn đến trình duyệt ở địa chỉ &lt;a href=&#34;http://127.0.0.1:8080/&#34;&gt;http://127.0.0.1:8080/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/yoxxe8lgj6_Screen%20Shot%202017-11-30%20at%2011.00.12%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So cool!&lt;/p&gt;

&lt;h1 id=&#34;execution-order&#34;&gt;Execution Order&lt;/h1&gt;

&lt;p&gt;Một điểm đặc biệt sẽ khiến hầu hết các bạn what the heck trong lần đầu tiên dùng convey là: &amp;ldquo;Quái sao cái giá trị của mình nó lúc thế này lúc thế kia vậy???&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Lấy một ví dụ nhé&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestSomething(t *testing.T) {
	Convey(&amp;quot;Prepare&amp;quot;, t, func() {
		a := 1
		b := 2
		Convey(&amp;quot;Add 1&amp;quot;, func() {
			a = a + 1
			So(a, ShouldEqual, 2)
			b = b + 1
			So(b, ShouldEqual, 3)
		})

		Convey(&amp;quot;Subtract 1 &amp;quot;, func() {
			a = a - 1
			So(a, ShouldEqual, ??)
			b = b - 1
			So(b, ShouldEqual, ??)
		})
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Theo các bạn thì ví dụ ở trên giá trị tương ứng với 2 dấu &lt;code&gt;??&lt;/code&gt;là gì?
Nhìn thì trên xuống, a = 1, b = 2. Sau khi đi qua hàm &lt;code&gt;Add 1&lt;/code&gt; thì a = 2, b = 3. Sau khi đi qua  &lt;code&gt;Subtract 1&lt;/code&gt; thì a lại về 1 và b về 2 đúng không?&lt;/p&gt;

&lt;p&gt;Hoàn toàn không. Kết quả sẽ là a = 0 và b = 1.
&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/q3xdoz9wgf_Screen%20Shot%202017-11-30%20at%2011.14.20%20PM.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; What the heck? Giá trị của &lt;code&gt;a&lt;/code&gt; unexpected. Well xin giới thiệu với các bạn, execution order của Convey:&lt;/p&gt;

&lt;p&gt;Ví dụ có structure convey như sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Convey A
    So 1
    Convey B
        So 2
    Convey C
        So 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thứ tự thực hiện không phải là &lt;code&gt;A1B2C3&lt;/code&gt; nhé. Mà là &lt;code&gt;A1B2A1C3&lt;/code&gt;. :))&lt;/p&gt;

&lt;p&gt;Convey có thứ tự execution như vậy là để hỗ trợ setup và tear down một cách tự nhiên hơn.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;			Convey(&amp;quot;Create&amp;quot;, func() {
				Convey(&amp;quot;Success&amp;quot;, func() {
					accountID := uuid.NewV4().String()
					role := randomRole(accountID, randomdata.StringNumber(4, &amp;quot;-&amp;quot;))
					_, err = core.CreateRole(role)
					So(err, ShouldBeNil)

					Reset(func() {
						arango.TruncateCollectionForTesting(
							cArango.RoleCollection,
						)
					})

					Convey(&amp;quot;AlreadyExist&amp;quot;, func() {
						role.ID = &amp;quot;&amp;quot;
						_, err := core.CreateRole(role)
						So(err, ShouldEqual, ErrRoleAlreadyExists)
					})

					Convey(&amp;quot;GetByID&amp;quot;, func() {
						r, err := core.GetRoleByID(role.ID)
						So(err, ShouldBeNil)
						So(r, ShouldResemble, role)
					})

					Convey(&amp;quot;GetByType&amp;quot;, func() {
						r, err := core.GetRoleByType(role.Type)
						So(err, ShouldBeNil)
						So(r, ShouldResemble, role)
					})
         })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ như đoạn code trên, việc setup teardown của mình chỉ cần khai báo một lần. Và các Convey phía sau sẽ có isolated context, giúp cho các test cases của mình không depend lẫn nhau.&lt;/p&gt;

&lt;h2 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h2&gt;

&lt;p&gt;Xài Convey đi.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Truyện tự viết - Biết đâu là định mệnh(p2)</title>
      <link>https://runivn.github.io/post/biet-dau-la-dinh-menh-2/</link>
      <pubDate>Sat, 29 Jul 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/biet-dau-la-dinh-menh-2/</guid>
      <description>&lt;p&gt;&amp;ndash; Ơ, sao biết em ngồi ở đây?&lt;/p&gt;

&lt;p&gt;&amp;ndash; Chỉ cần một chút quan sát thôi mà.&lt;/p&gt;

&lt;p&gt;Nàng đưa mắt lên nhìn người đối diện. Một phiên bản ngoài đời của avatar facebook, tóc loe hoe, mắt đeo kính cận, có điều ở ngoài có đôi chút khí chất hơn.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Anh đến đây từ mấy giờ?&lt;/p&gt;

&lt;p&gt;Chàng xoa xoa sống mũi, khẽ đẩy mắt kiếng.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Bảy giờ. Anh không nghĩ là em sẽ tới đấy.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Tối mùng một không biết làm gì, kiểu vậy&amp;rdquo;, nàng bâng quơ.&lt;/p&gt;

&lt;p&gt;Chàng tìm một cái gì đó để bắt đầu cuộc trò chuyện.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Kể anh nghe về ngày đầu năm của em đi&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Cũng không có gì đặc biệt, ngoại trừ em cho vài người trong dòng họ em đảo lộn vai vế một cách không chính thức thôi.&amp;rdquo;, nàng nhún vai, bộ dạng cực kì đáng yêu.&lt;/p&gt;

&lt;p&gt;Chàng và nàng đều là hai người cực kì ít nói, nếu cho hai người hai cuốn sách, ắt hẳn sẽ không nói với nhau một câu, đọc hết và ra về.&lt;/p&gt;

&lt;p&gt;Nhưng hôm nay là mùng một, và cũng là lần đầu tiên gặp nhau.&lt;/p&gt;

&lt;p&gt;Chàng chìa ra một cuốn truyện.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Tặng em, coi như quà gặp mặt.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Á, sao anh biết em thích Nguyễn Nhật Ánh, và còn truyện mới sáng tác nữa.&amp;rdquo;, nàng ngạc nhiên, miệng không giấu được nụ cười.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Còn bất ngờ nữa, em mở sách ra đi.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Đầy thắc mắc, nàng lật sang trang đầu của cuốn &amp;ldquo;Bảy bước tới mùa hè&amp;rdquo;, cuốn sách nàng đang trông ngóng ngày phát hành.&lt;/p&gt;

&lt;p&gt;Một lời đề tặng &amp;ldquo;Chúc cháu tìm được hạnh phúc thật sự của mình.&amp;rdquo;, phía dưới là chữ kí Nguyễn Nhật Ánh.&lt;/p&gt;

&lt;p&gt;Nàng bỏ sách xuống, ngước nhìn con người trước mặt. Rốt cuộc thì anh ba đầu sáu tay kiểu gì, mà có thể có sách chưa xuất bản, lại còn chữ kí độc quyền nữa.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Anh là con của chú Ánh?&amp;rdquo;, nàng tròn xoe mắt.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Haha dĩ nhiên là không.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Thế sao anh có những thứ này?&amp;rdquo;, nàng chỉ vào cuốn sách.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &amp;ldquo;Muốn thì sẽ có cách thôi em.&amp;rdquo;, chàng nheo mắt, tỏ vẻ úp mở.&lt;/p&gt;

&lt;p&gt;Nàng không có hứng thú với việc điều tra nguồn gốc mọi chuyện. Hầu như chuyện gì cũng vậy, nàng đều hiểu nó sẽ có nguyên nhân và kết quả, cái gì được biết thì sẽ biết thôi.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Nếu anh không muốn nói thì thôi. Cơ mà em thích lắm. Cám ơn anh nhé. Anh cũng thích truyện chú Ánh sao?&amp;rdquo;, nàng cười rõ tươi.&lt;/p&gt;

&lt;p&gt;Chủ đề về sách kéo nàng và chàng nhập tâm trong cuộc trò chuyện đến nỗi, nàng giật mình khi nhân viên thông báo đóng cửa quán.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Tiêu rồi, mười một giờ rồi nè. Em phải về đây.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Để anh đưa em về.&lt;/p&gt;

&lt;p&gt;&amp;ndash; Không cần đâu, em phóng một mình cho nhanh. Cám ơn anh về cuốn sách nhé, hẹn gặp lại anh.&lt;/p&gt;

&lt;p&gt;Nói xong nàng vội xuống lấy xe. Hôm nay là ngày Tết, chứ nếu là ngày thường, mười giờ nhà nàng đã ngủ cả rồi.&lt;/p&gt;

&lt;p&gt;Có một điều mà tới lúc về nhà nàng mới nhận ra, nàng chưa hỏi tên người đã tặng sách mình.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Truyện tự viết - Biết đâu là định mệnh(p1)</title>
      <link>https://runivn.github.io/post/biet-dau-la-dinh-menh/</link>
      <pubDate>Thu, 27 Jul 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/biet-dau-la-dinh-menh/</guid>
      <description>&lt;p&gt;Mùng một Tết, nàng ngủ tới tận 11h sáng.&lt;/p&gt;

&lt;p&gt;Việc đầu tiên năm mới của nàng là lướt facebook, xem người ta chúc Tết. Inbox hiện năm mươi mốt tin nhắn, chủ yếu là bạn bè thân quen. Nàng lướt một vòng, mắt nàng dừng lại ở một nick lạ, &amp;ldquo;Nam moi vui ve, hi vong nam nay se duoc lam quen voi em&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Nàng bật cười: &amp;ldquo;Cũng thú vị, đầu năm bổn cô nương đại xá thiên hạ, add friend người không quen biết thử xem sao&amp;rdquo;. Nhìn kĩ avatar của người này, một bức chân dung được phác họa dưới nét chì, cực kì ngộ nghĩnh, đầu chỉ loe hoe vài ba cọng tóc, và tuyệt nhiên, khuôn mặt ko nở nụ cười, đúng hơn là một vẻ bất cần. Nàng nhấn nút chấp nhận kết bạn rồi đóng chiếc laptop lại, vươn vai hít thở khí trời đầu năm.&lt;/p&gt;

&lt;p&gt;Nàng tên là Ngọc Duyên, á khôi của khoa Anh ngữ trường Đại học Sư Phạm. Còn 6 tháng nữa thôi là nàng chính thức trở thành một cô giáo, ước mơ thuở bé của nàng đã sắp trở thành hiện thực. Nàng là người có tâm hồn lãng mạn, luôn tự cho rằng thế gian này điều tuyệt vời nhất là tình yêu. Thế nhưng đến nay vẫn chưa có một mối tình vắt vai vì nàng bảo chưa có ai mang lại cho nàng một cảm giác đặc biệt.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Chao nam moi&amp;rdquo;. Một cửa sổ chat cùng khuôn mặt loe ngoe mấy cọng tóc hiện ra.&lt;/p&gt;

&lt;p&gt;Quái, trên đời cũng có kẻ mùng một Tết ở nhà lướt net như mình à!?!&lt;/p&gt;

&lt;p&gt;Nàng lạnh lùng: &amp;ldquo;Quen không?&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Hien gio thi chua, nhung roi se quen thoi.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Nàng im lặng, &amp;ldquo;Tự tin gớm, may là Tết nhất không là ăn chửi rồi đấy&amp;rdquo;, nàng nghĩ.
j
Bên kia tiếp:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Mung mot thi lam gi?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Ngủ, ăn, lát về thăm ông bà. Tối làm gì chưa biết.&amp;rdquo;, nàng lạnh lùng.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Gap nhau dau nam nhe, toi nay doi em o Coffee House Cao Thang.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Haha, điên&amp;rdquo;. Nàng tắt facebook, vội chạy đi thay đồ rồi cùng ba mẹ về quê nội.&lt;/p&gt;

&lt;p&gt;Quê nội nàng ở Đồng Nai, cách Sài Thành trăm cây số. Mỗi dịp đầu năm, nhà nội nàng đều tụ tập đông đủ dòng họ về thăm. Riêng khoản nhớ tên họ hàng đủ để nàng nhức đầu, vì nội có tới 8 người con, và ai cũng con cháu đề huề. Năm nào nàng cũng toàn muốn tìm lỗ chui xuống đất vì chào nhầm em thành anh, ông thành bác. Năm nay rút kinh nghiệm, ai mà không nhớ mặt, nàng chỉ mỉm cười và gật đầu, thế là thoát nạn.&lt;/p&gt;

&lt;p&gt;Bà nàng năm nay đã ngoài 90. Bà thương nàng lắm, lần nào về cũng kéo lại hỏi hết chuyện này đến chuyện khác. Vấn đề muôn thuở, &amp;ldquo;Năm nay lại không dắt ai về à, con mau mau kiếm ai chứ bà dạo này thấy bà không được khỏe như ngày trước đâu đấy&amp;rdquo;. Nàng cười hiền: &amp;ldquo;Dạ thế thì con muốn ế dài dài, để bà mãi sống với con cháu&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Hội họp chán chê, 5h chiều nàng mới về tới nhà.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Facebook có tin nhắn của ai đây? Mặc kệ, đi tắm đã&amp;rdquo;, nàng quăng điện thoại lên giường.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Py ơi xuống ăn cơm!&amp;rdquo;. Mẹ gọi, Py là tên ở nhà của nàng.&lt;/p&gt;

&lt;p&gt;Hôm nay mùng một, nhà nàng ăn chay, cơ mà mẹ nàng tay nghề cực cao, nấu toàn các món ăn lạ nên cả nhà ăn rất ngon miệng. Vừa ăn nàng vừa hỏi ba về các người quen lúc chiều gặp nhưng không nhớ ra đó là ai.&lt;/p&gt;

&lt;p&gt;Ăn xong, cả nhà lên phòng khách cùng coi ti vi và trò chuyện, nàng ở lại rửa chén. Xong việc, sực nhớ chưa trả lời tin nhắn, nàng chạy vội lên phòng tìm điện thoại.&lt;/p&gt;

&lt;p&gt;Là tin nhắn từ đầu tóc loe hoe, một bức hình chụp ở quán cafe, chắc là Coffee House. Nàng xem đồng hồ, bây giờ đã 8h, thời gian gửi thì đã ba tiếng trước.&lt;/p&gt;

&lt;p&gt;Nàng lấy xe, ra khỏi nhà. Thật ra thì nàng không phải muốn tới gặp người đó, mà là muốn dạo phố phường, uống một cốc trà đào vào ngày đầu năm mà thôi. &amp;ldquo;Ở nhà giờ này cũng chả làm gì&amp;rdquo;, nàng bâng quơ.&lt;/p&gt;

&lt;p&gt;Sài gòn vào Tết, giống như thay một bộ mặt khác. Đường phố rộng rãi, không kẹt xe, khắp nơi đều trang trí rực rỡ. Chú giữ xe cũng mặc đẹp hơn ngày thường. Nàng chọn một chỗ ngồi, nhâm nhi vị trà đào yêu thích, không quên lôi messenger ra chụp ảnh và gửi cho tên đầu tóc loe hoe.&lt;/p&gt;

&lt;p&gt;Seen.&lt;/p&gt;

&lt;p&gt;“Hẳn là đã về rồi”, nàng thầm nghĩ. Bộ dạng không quan tâm, nàng tìm vài người bạn và nhắn tin chúc Tết.&lt;/p&gt;

&lt;p&gt;“Chào em, anh nè”.
(Còn tiếp).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Single endpoint với GraphQL (backend Go)</title>
      <link>https://runivn.github.io/post/graphql/</link>
      <pubDate>Sat, 22 Jul 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/graphql/</guid>
      <description>

&lt;p&gt;GraphQL được tạo ra bởi Facebook vào năm 2012, production ready năm 2016 nhưng hiện tại vẫn khá ít công ty và developers Việt Nam sử dụng. Nhân tiện có một khách hàng muốn xài GraphQL nên team mình đã apply vào luôn. Sau khi xài xong thì thấy khá kute phô mai que nên muốn share ít kiến thức tìm hiểu được.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/lq5y5mw0h0_image.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;h1 id=&#34;problem&#34;&gt;Problem&lt;/h1&gt;

&lt;p&gt;Để hiểu được concreate problem của GraphQL thì phải nói tới REST.&lt;/p&gt;

&lt;h2 id=&#34;rest&#34;&gt;REST&lt;/h2&gt;

&lt;p&gt;Chắc hẳn mọi người đều đã làm việc với REST rồi.
Có rất nhiều thứ để nói về REST, mình sẽ tóm gọn lại một cách dễ hiểu.
REST hay Representational state transfer là tập hợp những architecture principles, qui định cách thức clients interact với server, giúp application có thể manage tài nguyên.&lt;/p&gt;

&lt;p&gt;Citizen của REST là &amp;ldquo;resource&amp;rdquo;. Khi bạn muốn retreive dữ liệu resource thì bạn dùng GET, khi muốn insert thì dùng POST&amp;hellip; kiểu vậy.&lt;/p&gt;

&lt;p&gt;Một điểm quan trọng đó là REST stateless và cacheable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/gggntnv456_image.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;rest-drawbacks&#34;&gt;REST drawbacks&lt;/h2&gt;

&lt;p&gt;Ứng dụng mình chia làm 2 phần, backend là Go và frontend là React. Mình bắt đầu gặp những vấn đề khi ứng dụng grows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Số lượng API endpoint quá nhiều, đôi lúc sẽ phải cầm cái id này chạy tới endpoint này kết quả, sau đó cầm tập id được response chạy tới endpoint khác để lấy cái thật sự cần.&lt;/li&gt;
&lt;li&gt;Rất khó để define ra được một chuẩn chung của dữ liệu trả về, vì đôi lúc với một model, client có thể lúc thì cần fields này, lúc thì cần những fields khác.&lt;/li&gt;
&lt;li&gt;Khi mà đổi một cái gì đó, ví dụ schema, thì không biết những chỗ nào bị impact.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;graphql-for-the-sake&#34;&gt;GraphQL for the sake&lt;/h1&gt;

&lt;p&gt;GraphQL là một internal project của Facebook, sau đó được opensourced. Nó là một query language cho phép clients construct resource mà bạn muốn server trả về.&lt;/p&gt;

&lt;p&gt;Ví dụ:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  me {
    name
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Đoạn query trên muốn khi gọi API thì lấy tên của chính mình. Kết quả trả về:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;me&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;Runi&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bạn có thể nhận ra query của nó gần như là một JSON mà bị missing value, và kết quả trả về là JSON với format đúng như client requests.&lt;/p&gt;

&lt;h1 id=&#34;rest-vs-graphql&#34;&gt;REST vs GraphQL&lt;/h1&gt;

&lt;p&gt;Thật ra so sánh 2 thằng này thì không hợp lý lắm, point ở đây là so sánh 2 thằng này &amp;ldquo;in practice&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Giống:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Đều là send data over HTTP request.&lt;/li&gt;
&lt;li&gt;Core idea đều là resource.&lt;/li&gt;
&lt;li&gt;Output cuối cùng là JSON là như nhau.&lt;/li&gt;
&lt;li&gt;Đều có cách phân biệt giữa write/read data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Khác:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;REST coupled giữa cách bạn define data và cách bạn retrieve nó. Ví dụ &lt;code&gt;/songs/1&lt;/code&gt;.  GraphQL separates endpoint và cách bạn lấy data.&lt;/li&gt;
&lt;li&gt;REST định nghĩa những thông tin resource ở server, clients chỉ make a call. GraphQL cho phép client đưa lên một datashape, nhiệm vụ server phải trả về đúng thông tin như vậy.&lt;/li&gt;
&lt;li&gt;Khi bạn muốn fetch nhiều related data bạn phải gọi multiple request ở REST. GraphQL cho phép bạn traverse entry point để lấy data bằng single request. (hacky way ở REST là tạo 1 endpoint mới gom response lại, too painful).&lt;/li&gt;
&lt;li&gt;Thay đổi read/write ở REST bằng http method, GraphQL bằng query.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Well, tới đây chắc các bạn cũng có một quick overview về GraphQL rồi. Mình sẽ apply vào Go backend xem thế nào.&lt;/p&gt;

&lt;h1 id=&#34;integrate-backend-go&#34;&gt;Integrate backend Go&lt;/h1&gt;

&lt;p&gt;Mình đã thử dùng GraphQL trên elixir và Ruby. Phải thừa nhận là vì dynamic language nên code &amp;hellip; rất sướng tay.
Trên Go thì hơi trâu bò một chút.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bài toán&lt;/strong&gt;: Mình sẽ tạo một endpoint GraphQL, dùng nó lấy random một bài hát trong database, và tạo một song mới.&lt;/p&gt;

&lt;p&gt;Mình sử dụng &lt;code&gt;github.com/graphql-go/graphql&lt;/code&gt; làm GraphQL implementation.&lt;/p&gt;

&lt;p&gt;Vì GraphQL idiomatic là chỉ dùng single endpoint, nên mình chỉ serve:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http.Handle(&amp;quot;/graphql&amp;quot;, graphHandler)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong đó&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func  graphHandler(w http.ResponseWriter, r *http.Request) {
    var schema, _ = graphql.NewSchema(graphql.SchemaConfig{
    Query:    query,
    Mutation: mutation,
    })

	result := graphql.Do(graphql.Params{
		Schema:        schema,
		RequestString: r.URL.Query().Get(&amp;quot;query&amp;quot;),
	})

	json.NewEncoder(w).Encode(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong GraphQL, &lt;strong&gt;query = read và  mutation = write.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hàm trên có thể hiểu, graphql handler sẽ đọc vào một cái schema, parse query string từ client gửi lên để lấy datashape, sau đó query data từ nơi nào đó trả về.&lt;/p&gt;

&lt;h2 id=&#34;query&#34;&gt;Query&lt;/h2&gt;

&lt;p&gt;Giờ mình sẽ construct query object để lấy bài hát.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var query = graphql.NewObject(graphql.ObjectConfig{
		Name: &amp;quot;Query&amp;quot;,
		Fields: graphql.Fields{
			&amp;quot;song&amp;quot;: &amp;amp;graphql.Field{
				Type: songType,
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
					song, err := getRandomSong()
					if err != nil {
						logrus.Errorf(&amp;quot;failed to random song, err = %v&amp;quot;, err)
						return nil, err
					}

					return song, nil
				},
			},
		},
	})



var songType = graphql.NewObject(graphql.ObjectConfig{
	Name:        &amp;quot;Song&amp;quot;,
	Description: &amp;quot;Song contains some information&amp;quot;,
	Fields: graphql.Fields{
		&amp;quot;id&amp;quot;: &amp;amp;graphql.Field{
			Type:        graphql.ID,
			Description: &amp;quot;Song&#39;s id&amp;quot;,
		},
		&amp;quot;title&amp;quot;: &amp;amp;graphql.Field{
			Type:        graphql.String,
			Description: &amp;quot;The title of the song.&amp;quot;,
		},
		&amp;quot;artist&amp;quot;: &amp;amp;graphql.Field{
			Type:        graphql.String,
			Description: &amp;quot;The artist of the song.&amp;quot;,
		},
	},
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có 2 thứ ở đây cần chú ý:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Type của object bạn muốn trả về, đoạn code trên là &lt;code&gt;songType&lt;/code&gt; qui định datashape mà client có thể query để lấy được.&lt;/li&gt;
&lt;li&gt;Resolve function:  Khi bạn viết một schema cho GraphQL, bạn phải viết resolve function cho nó. GraphQL execution engine sẽ invoke function này khi data thật sự được queried.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Như vậy với đoạn code trên, nếu không có gì xảy ra thì khi make request với query như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;query {
	song {
    	id
  		title
		artist
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sẽ được kết quả&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;song&amp;quot;: {
        &amp;quot;id&amp;quot;: 1,
        &amp;quot;title&amp;quot;: &amp;quot;Chieu Hom Ay&amp;quot;,
        &amp;quot;artist&amp;quot;: &amp;quot;Jaykii&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Match exactly với schema chúng ta vừa định nghĩa.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Vậy còn nếu muốn random một bài hát, mà có theo &lt;code&gt;tag&lt;/code&gt; do client gửi lên thì sao?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GraphQL hỗ trợ arguments, ta sẽ sửa lại code schema:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var query = graphql.NewObject(graphql.ObjectConfig{
		Name: &amp;quot;Query&amp;quot;,
		Fields: graphql.Fields{
			&amp;quot;song&amp;quot;: &amp;amp;graphql.Field{
				Type: songType,
                Args: graphql.FieldConfigArgument{
					&amp;quot;tag&amp;quot;: &amp;amp;graphql.ArgumentConfig{
						Type: graphql.String,
					},
				},
				Resolve: func(p graphql.ResolveParams) (interface{}, error) {
                	tag := p.Args[&amp;quot;tag&amp;quot;].(string)
					song, err := getRandomSongByTag(tag)
					if err != nil {
						logrus.Errorf(&amp;quot;failed to random song by tag, err = %v&amp;quot;, err)
						return nil, err
					}

					return song, nil
				},
			},
		},
	})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vậy query string của chúng ta sẽ thay đổi một chút thành:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;query {
	song(tag: &amp;quot;us&amp;quot;) {
    	id
  		title
		artist
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kết quả sẽ random ra 1 bài hát có tag là &amp;ldquo;us&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;song&amp;quot;: {
        &amp;quot;id&amp;quot;: 12,
        &amp;quot;title&amp;quot;: &amp;quot;Leave out all the reset&amp;quot;,
        &amp;quot;artist&amp;quot;: &amp;quot;Linkin Park&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mutation&#34;&gt;Mutation&lt;/h2&gt;

&lt;p&gt;GraphQL tư tưởng là dùng để ease for querying data là chính, nhưng với một data platform hoàn chỉnh thì phải phải hỗ trợ cả việc modify data trên server.&lt;/p&gt;

&lt;p&gt;Bên REST không khuyến khích bạn modify data bằng &lt;code&gt;GET&lt;/code&gt; request. Nhưng thật ra bạn vẫn làm được (nhét hết lên url params chẳng hạn, có điều url thì có limit length).  Bên GraphQL cũng vậy, bạn thậm chí có thể write data bằng query, nhưng nó ko đúng convention. GraphQL cung cấp &lt;code&gt;mutation&lt;/code&gt; để làm chuyện này.&lt;/p&gt;

&lt;p&gt;Ví dụ bạn muốn tạo một bài hát mới, chúng ta sẽ viết một song mutation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var mutation = graphql.NewObject(graphql.ObjectConfig{
	Name: &amp;quot;Mutation&amp;quot;,
	Fields: graphql.Fields{
		&amp;quot;createSong&amp;quot;: &amp;amp;graphql.Field{
			Type:        songInputType,
			Description: &amp;quot;Create new song&amp;quot;,
			Args: graphql.FieldConfigArgument{
				&amp;quot;title&amp;quot;: &amp;amp;graphql.ArgumentConfig{
					Type: graphql.NewNonNull(graphql.String),
				},
				&amp;quot;artist&amp;quot;: &amp;amp;graphql.ArgumentConfig{
					Type: graphql.NewNonNull(graphql.String),
				},
			},
			Resolve: func(params graphql.ResolveParams) (interface{}, error) {
				title, _ := params.Args[&amp;quot;title&amp;quot;].(string)
				artist, _ := params.Args[&amp;quot;artist&amp;quot;].(string)

				song := &amp;amp;domain.Song{
                   		Title: title,
                   		Artist: artist,
                   }

				err := saveSong(song)
				if err != nil {
                	logrus.Errorf(&amp;quot;failed to save song, err = %v&amp;quot;, err)
					return nil, err
				}

				return song, nil
			},
		},
	},
})

var songInputType = graphql.NewInputObject(graphql.InputObjectConfig{
	Name:        &amp;quot;Song&amp;quot;,
	Description: &amp;quot;Song inputs&amp;quot;,
	Fields: graphql.InputObjectConfigFieldMap{
		&amp;quot;title&amp;quot;: &amp;amp;graphql.InputObjectFieldConfig{
			Type:        graphql.String,
			Description: &amp;quot;The title of the song.&amp;quot;,
		},
		&amp;quot;artist&amp;quot;: &amp;amp;graphql.InputObjectFieldConfig{
			Type:        graphql.String,
			Description: &amp;quot;The artist of the song.&amp;quot;,
		},
	},
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GraphQL phân biệt kiểu Input và Output. Các bạn có thể hiểu đơn giản là Output =&amp;gt; cho những thứ để export ra và Input là các giá trị được truyền vào. Output và Input cùng một model nhưng có thể có schema khác nhau, Output có thể chứa nhiều complex data type hơn.&lt;/p&gt;

&lt;p&gt;Trong ví dụ trên là songInputType sẽ là datashape của các parameters mà clients sẽ gửi lên. Khi đó mutation của chúng ta sẽ là:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mutation {
	createSong(title: &amp;quot;Co em cho&amp;quot;, artist: &amp;quot;Min&amp;quot;) {
    	id
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tức là chúng ta đang muốn tạo một bài hát mới với given title + artist, sau khi tạo xong thì trả về id.
Kết quả mong đợi sẽ là&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;createSong&amp;quot;: {
    	&amp;quot;id: 16
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy là chúng ta đã biết cách để read/write data với GraphQL.&lt;/p&gt;

&lt;h1 id=&#34;combo-với-frontend&#34;&gt;Combo với frontend&lt;/h1&gt;

&lt;p&gt;Đây là backend, vậy frontend thì chúng ta có gì?
- Với Vue thì bọn mình sử dụng &lt;a href=&#34;https://github.com/Akryum/vue-apollo&#34;&gt;Vue-apolo&lt;/a&gt;
- React thì dùng &lt;a href=&#34;https://github.com/facebook/relay&#34;&gt;Relay&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ngoài ra các bạn nào chưa muốn chuyển giao công nghệ kịp cả hai platform, thì có thể chơi thằng này &lt;a href=&#34;http://join-monster.readthedocs.io/en/latest/&#34;&gt;join monster&lt;/a&gt;. Đại loại là một query planner, sinh ra optimal sql query. Bạn có interface cho GraphQL (viết frontend sướng quá chừng), backend thì đỡ phải cài lại query. :3.&lt;/p&gt;

&lt;p&gt;Vã quá thì bạn nào xài posgres có thể chơi &lt;a href=&#34;https://github.com/postgraphql/postgraphql&#34;&gt;postgraphql&lt;/a&gt; bụp 1 cái tự instropect schema, tự gen API GraphQL luôn.&lt;/p&gt;

&lt;h1 id=&#34;tổng-kết&#34;&gt;Tổng kết&lt;/h1&gt;

&lt;p&gt;GraphQL rất thích hợp khi mà product của bạn có các clients cần flexible response format, lúc thì cần như thế này, lúc cần như thế kia mà không cần backend phải thay đổi.
Ngoài ra GraphQL cũng giúp drops TCP requests + network round trip với single endpoint.&lt;/p&gt;

&lt;p&gt;Với GraphQL cách approach của bạn sẽ natural hơn, tức là suy nghĩ cái mình cần trả về, thay vì suy nghĩ cách lấy đầu tiên. Điều này có thể speed up development.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/6hcpcxbkdv_image.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Q: GraphQL có drawbacks không?&lt;/p&gt;

&lt;p&gt;A: Có chứ, khá nhiều đấy. Một số ví dụ như: không thể versioned, painful khi xử lý upload hay validation, cache các kiểu không safe (DataLoader)&lt;/p&gt;

&lt;p&gt;Q: Vậy xài chung REST và GraphQL được không?&lt;/p&gt;

&lt;p&gt;A: Hoàn toàn CÓ. Hai thằng này có thể bổ sung cho những khuyết điểm của nhau. Đôi bạn cùng tiến.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goroutine under the hood</title>
      <link>https://runivn.github.io/post/go-routine-under-the-hood/</link>
      <pubDate>Tue, 28 Mar 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-routine-under-the-hood/</guid>
      <description>

&lt;p&gt;Chắc các bạn cũng không lạ lẫm gì Go nữa, Go là một ngôn ngữ backend được phát triển bởi Google.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/h46t11xlnx_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Một vài điểm mạnh nổi bật trong Go:
- Static binaries
- Concurrency
- High performance&lt;/p&gt;

&lt;p&gt;Trong đó concurrency được coi là first class citizen. Trong bài này mình sẽ đi sâu vào goroutines và cơ chế hoạt động của nó.&lt;/p&gt;

&lt;h1 id=&#34;một-ít-kiến-thức-căn-bản&#34;&gt;Một ít kiến thức căn bản&lt;/h1&gt;

&lt;h3 id=&#34;phân-biệt-parallelism-và-concurrenncy&#34;&gt;Phân biệt parallelism và concurrenncy:&lt;/h3&gt;

&lt;p&gt;Cả hai đều là cách để thực hiện multi processing programming, nhưng:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concurrency là việc handle nhiều thứ cùng một lúc. Thử tưởng tượng bạn đang tung bóng và bắt bóng trên tay, bạn có 4 quả bóng, nhưng một lúc bạn chỉ có thể tung một quả bằng tay phải, giữ một quả bằng tay trái và hai quả còn lại ở trên bầu trời.&lt;/li&gt;
&lt;li&gt;Parallelism là việc nhiều tác vụ đang chạy cùng một lúc(ví dụ multi processor). Bạn có thể vừa giặt đồ, vừa đọc sách, 2 tác vụ này chạy song song với nhau và không cần xài chung tài nguyên gì.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;phân-biệt-preemptive-scheduling-và-cooperative-scheduling&#34;&gt;Phân biệt preemptive scheduling và cooperative scheduling:&lt;/h3&gt;

&lt;p&gt;Tại mỗi thời điểm chỉ có một process được thực thi, vì vậy sẽ có nhiều loại scheduling CPU sao cho đạt hiệu quả tùy mục đích sử dụng nhất.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preemptive scheduling là khi các process sẵn sàng nhường quyền điều khiển CPU.&lt;/li&gt;
&lt;li&gt;Cooperative(hay còn gọi là non premptive): Khi một process được điều phối CPU, nó sẽ sử dụng CPU cho đến khi nó giải phóng(bằng cách kết thúc hoặc qua next state).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;phân-biệt-process-thread-và-goroutine&#34;&gt;Phân biệt process, thread và goroutine:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Process hiểu nôm na là một tiến trình xử lý của máy tính. Thuở xa xưa, máy tính chỉ chạy được một process trong một thời điểm. Khi multi processing ra đời, &lt;a href=&#34;https://en.wikipedia.org/wiki/Time-sharing&#34;&gt;time sharing model&lt;/a&gt; trở nên phổ biến. Mỗi process sẽ cung cấp resource riêng biệt để thực hiện chương trình.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Time sharing là một cách để share resource của máy tính cho các process, hay nói cách khác là các process có thể đồng thời làm việc trên một single core computer.&lt;/p&gt;

&lt;p&gt;Nói vậy thôi, nhưng nó chỉ là &amp;ldquo;ảo ảnh&amp;rdquo; của concurrency. Thực chất trong đó là việc switch sự phân bố của CPU rất nhanh giữa các active process với nhau. Để làm được chuyện đó cần phải lưu lại state của một process, và khởi động lại state của một process khác.&lt;/p&gt;

&lt;p&gt;Đó chính là context switching.&lt;/p&gt;

&lt;p&gt;Context switching cost cho các process rất nặng nề, bao gồm việc phải store tất cả register của CPU.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Thấy nặng nề quá nên đẻ ra thằng thread. Thread thật ra giống y chang process, nhưng nó là thực thể nằm trong process, và được cái là cho phép share resource. Process này không thể xài chung tài nguyên với process khác, nhưng thread trong cùng một process có thể xài chung tài nguyên với nhau.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tuy vậy, cost để context switching giữa các thread còn khá cao, vì mỗi thread cũng chứa rất nhiều state.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Goroutine lấy ý tưởng của thread và phát huy. Thử tìm hiểu xem sao.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;goroutine&#34;&gt;Goroutine&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/fy6g2oyuqm_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Các bạn hiểu nôm na một goroutine là một function mà có thể chạy đồng thời với các function khác. Các goroutine share nhau address space.
Không khác gì thread nhỉ?&lt;/p&gt;

&lt;p&gt;Một số đặc điểm goroutine:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Goroutine là cooperative.&lt;/li&gt;
&lt;li&gt;Compiler sẽ biết register nào được sử dụng vào tự động lưu nó&lt;/li&gt;
&lt;li&gt;Context switch của Goroutine xảy ra ở 2 thời điểm: khi một go routine đang chờ data để xử lý (channel operation) hoặc cần thêm space để nhét data (IO, GC).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;so-sánh-goroutine-và-thread&#34;&gt;So sánh goroutine và thread&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Về bộ nhớ: Bạn khởi tạo một goroutine chỉ mất 4Kb stack trong khi khởi tạo một thread thì lại cần từ 1- 4Mb. =&amp;gt; Dùng goroutine để multiplex request cho server vô cùng đơn giản khi bạn có thể spawn cả chục nghìn go routine, còn nếu 1 thread - 1 request thì rất dễ dẫn tới out of memory.&lt;/li&gt;
&lt;li&gt;Setup/teardown cost: Thread sẽ expensive trong việc này vì bạn phải request OS resource và trả lại khi dùng xong(thường cách hay dùng sẽ là thread pool để hạn chế việc này). Còn với goroutine thì việc khởi tạo/hủy đều thực hiện ở run time và cost cho việc này rất rẻ.&lt;/li&gt;
&lt;li&gt;Context switching: Thread sử dụng preemptive scheduling, khi switch phải save/restore 16 registers trong khi Go routine sử dụng cooperative và chỉ cần 3 register(PC, DX, SP).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;multiplex-goroutine&#34;&gt;Multiplex goroutine&lt;/h1&gt;

&lt;p&gt;Bởi vì Goroutine là cooperative, nên OS gần như không còn dính dáng tới việc đưa ra quyết định schedule. Đảm nhận việc này là Go scheduler.&lt;/p&gt;

&lt;p&gt;Có 3 model cơ bản trong multi threading. Đó là N:1, 1:1 và N:M&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N:1(user space thread) là khi có nhiều thread chạy trên cùng một OS thread. Cùng một OS thread thì cho phép việc context switch rất nhanh, nhưng lại không thể tận dụng được multi core system. Tức là trong một lúc chỉ có một thread được execute, như vậy nếu 1 thread đang bị block bởi IO, thì mấy thread khác cũng không thể làm gì được.&lt;/li&gt;
&lt;li&gt;1:1(kernel thread) là 1 thread sẽ gắn với một OS thread. Cái này thì multi core được, nhưng context switch lại expensive.&lt;/li&gt;
&lt;li&gt;N:M, đây là cách của Go sử dụng, chắc các bạn cũng đoán được, đó là N go routines sẽ chạy được trên M OS thread. Như vậy sẽ vừa quick context switch vừa tận dụng được multi core. Cơ mà để làm được như vậy, thì Go scheduler phải tay to, và xử lý cực kì phức tạp.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;go-scheduler&#34;&gt;Go scheduler&lt;/h1&gt;

&lt;p&gt;Trong Go scheduler sẽ có 3 thực thể. M P G&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7tt20uu4gq_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;M đại diện cho OS thread.(machine)&lt;/p&gt;

&lt;p&gt;P là processor, nó sẽ giữ context tương ứng với một OS thread.&lt;/p&gt;

&lt;p&gt;G là goroutine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/ndz0upn5ir_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Trên hình trên chúng ta thấy được 2 M, có giữ context P, mỗi cái sẽ chạy một goroutine G (Lưu ý là để chạy goroutine, M phải giữ context P)&lt;/p&gt;

&lt;p&gt;G màu xám là những go routine đang pending, và sẵn sàng để được schedule. Mỗi context P sẽ nắm giữ một list G màu xám như vậy. Cứ mỗi &lt;code&gt;go&lt;/code&gt; statement được chạy, nó sẽ được add vào run queue. Khi tới thời điểm, context sẽ pop một goroutine ra, allocate cho nó lên stack, set cho nó một instruction pointer và cho nó chạy.&lt;/p&gt;

&lt;p&gt;M và G hẳn là đã rõ rồi, cơ mà P ở đây vai trò là gì? Tại sao không gắn thẳng goroutine vào thread mà phải thông qua context?&lt;/p&gt;

&lt;p&gt;Nó sẽ rơi vào trường hợp sau đây, đó là khi thread đang chạy bị block. Nguyên nhân gây ra block có thể là IO hay GC.
Ví dụ khi gọi system call, ghi file chẳng hạn, thì trong thời gian block, go scheduler sẽ pass context này cho thread khác để có thể tiếp tục chạy.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/djsaexr43v_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Như hình trên, M0 đang handling một cái syscall, điều này làm những goroutine trong running queue sẽ ko được schedule, nên Go scheduler sẽ pass context P cho M1. Lưu ý là M1 có thể được tạo ra trong lúc đó, hoặc lấy ra từ thread cache.&lt;/p&gt;

&lt;p&gt;Khi M0 làm xong syscall, thì nó sẽ:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tìm kiếm xung quanh, bằng cách chôm &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; goroutine run queue của thread khác&lt;/li&gt;
&lt;li&gt;Nếu không tìm thấy gì, nó sẽ đặt mình vào thread cache và ngủ.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tại-sao-goroutine-lại-nhẹ-như-vậy&#34;&gt;Tại sao Goroutine lại nhẹ như vậy?&lt;/h1&gt;

&lt;p&gt;Để khởi tạo goroutine chỉ mất tầm 4KB trong khi bạn cần 4Mb để có thể tạo ra một thread.&lt;/p&gt;

&lt;p&gt;Lí do là Goroutine có thể tăng/giảm kích thước khi cần trong lúc runtime(dynamic allocation).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/5nb52d9gmf_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Go sử dụng segmented stacks. Cho các bạn chưa biết thì segmented stacks là loại stack mà cho phép tăng/giảm stack space tùy vào mục đích sử dụng, và quá trình này thực hiện ở runtime.&lt;/p&gt;

&lt;p&gt;Quá trình tăng stack khi cần thiết của một go routine sẽ thực hiện như sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Một go routine khi init sẽ có 4KB space&lt;/li&gt;
&lt;li&gt;Nếu quá tải, Go runtime sẽ allocate thêm stack. Việc quản lý một function có run out of memory hay không được thực hiện bởi &lt;code&gt;prologue&lt;/code&gt;. Mỗi function đều có một prologue để quản lý bộ nhớ.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;goroutine-blocking&#34;&gt;Goroutine blocking&lt;/h1&gt;

&lt;p&gt;Goroutine sẽ bị block trong các trường hợp sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Network&lt;/li&gt;
&lt;li&gt;Sleep&lt;/li&gt;
&lt;li&gt;Channel operations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Khi một goroutine bị block, nó sẽ không khiến thread mà nó đang nằm trên bị ảnh hưởng theo.&lt;/p&gt;

&lt;p&gt;Nếu các bạn để ý, goroutines giống như một lớp abstraction của thread. Nó giúp programmer không phải làm việc trực tiếp với threads, và OS thì hầu như không biết sự tồn tại của go routine.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/mhqrpx4uab_Screen%20Shot%202017-03-28%20at%205.06.11%20PM.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Cái mà OS thấy chỉ đơn giản là một process ở user level xin được cấp phát và chạy multiple threads. Việc schedule goroutines trên threads tất tần tật chỉ đơn thuần là việc xây dựng một môi trường ảo ở runtime.&lt;/p&gt;

&lt;p&gt;Tất cả I/O trong Go đều là blocking. Vậy xử lý những tác vụ async như network I/O thì như thế nào?&lt;/p&gt;

&lt;p&gt;Để giải quyết vấn đề async IO thì trong Go sẽ có một phần để convert từ non-blocking sang blocking I/O. Phần này gọi là &lt;code&gt;netpoller&lt;/code&gt;. Công việc nó là nó sẽ ngồi và đợi events từ các goroutines mà muốn thực hiện network I/O, sau đó dựa vào tập file descriptor từ OS để quyết định goroutines nào sẽ được perform I/O.&lt;/p&gt;

&lt;h1 id=&#34;q-a&#34;&gt;Q&amp;amp;A&lt;/h1&gt;

&lt;p&gt;Q: Tuy context switch của goroutines rẻ, nhưng mà giờ có cả triệu goroutines thì nó cũng chậm chứ?&lt;/p&gt;

&lt;p&gt;A: Hỏi hay đấy, nhưng go scheduler cũng giống thread scheduler. Với các OS ngày nay thì độ phức tạp của scheduling algo là O(1). Nên việc có bao nhiêu goroutines không ảnh hưởng tới context switch cost.&lt;/p&gt;

&lt;p&gt;Q: Ủa sao cái blocking goroutine mechanism của netpoller nhìn giống giống epoll/kqueue trong Unix vậy.&lt;/p&gt;

&lt;p&gt;A: Pro ghê, cách mà goroutines được xử lý khi bị blocking khá giống với event driven trong C. Thật ra under the hood thì Go cũng sử dụng epoll/kqueue luôn. Bạn có thể đọc source Go ở &lt;a href=&#34;https://golang.org/src/runtime/netpoll.go&#34;&gt;netpoller&lt;/a&gt; để tìm hiểu thêm.&lt;/p&gt;

&lt;h1 id=&#34;nguồn&#34;&gt;Nguồn&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Analysis of the Go runtime scheduler - &lt;a href=&#34;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&#34;&gt;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Go net poller - &lt;a href=&#34;https://morsmachine.dk/netpoller&#34;&gt;https://morsmachine.dk/netpoller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Go scheduler - &lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;https://morsmachine.dk/go-scheduler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Why Go routines stack infinite - &lt;a href=&#34;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&#34;&gt;https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;How Go routines work - &lt;a href=&#34;http://blog.nindalf.com/how-goroutines-work/&#34;&gt;http://blog.nindalf.com/how-goroutines-work/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>MIR - Sự tinh túy của chú cua bé nhỏ Rust</title>
      <link>https://runivn.github.io/post/rust-mir/</link>
      <pubDate>Sat, 04 Feb 2017 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/rust-mir/</guid>
      <description>

&lt;p&gt;Dạo này Rust đang nổi lên như một thế lực khiến một hispter như mình không thể không để tâm. Sau vài ngày dig deeper vào Rust, mình cho rằng Rust là một ngôn ngữ khá hay để &amp;ldquo;học&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/cxmz5ldc6t_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Lý do:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rust giống C/C++, học Rust các bạn có thể giải các bài toán liên quan tới vùng nhớ- điều mà các Rubylist, Pythonist không quan tâm.&lt;/li&gt;
&lt;li&gt;Có ownership + borrow system để hỗ trợ memory safety.&lt;/li&gt;
&lt;li&gt;Traits để generic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Và đặc biệt là, Rust là một ngôn ngữ &lt;em&gt;compiler driven&lt;/em&gt;, tức là khi cái app bạn build nó không bị compiler nhả lỗi, bạn đã có một chương trình safe + performance. Suy ra cái đáng để tìm hiểu ở đây là compiler :troll:&lt;/p&gt;

&lt;p&gt;Vì vậy mình sẽ giới thiệu các bạn một chút về cái làm nên tên tuổi của và chỉ có ở Rust -  MIR.&lt;/p&gt;

&lt;p&gt;Cơ mà để hiểu được, cần có một số kiến thức căn bản.&lt;/p&gt;

&lt;h1 id=&#34;compiler-là-gì&#34;&gt;Compiler là gì&lt;/h1&gt;

&lt;p&gt;Như các bạn đã biết, mã máy(machine code) là một loại ngôn ngữ lập trình mà chỉ bao gồm hai con số 0 và 1. Với khả năng readable gần như bằng 0, ngôn ngữ máy không thể dùng phổ biến cho việc lập trình. Điều này dẫn tới việc ra đời của các ngôn ngữ cấp cao. Đặc điểm của hướng tiến hóa là càng ngày càng gần với ngôn ngữ tự nhiên. Tuy nhiên, machine code là thứ duy nhất mà CPU có thể hiểu được. Vì vậy, với mỗi loại ngôn ngữ sinh ra, đều có đi kèm song song một công cụ để biên dịch từ mã nguồn cấp cao sang mã nguồn cấp thấp có thể execute được. Đó là compiler.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/7s2d1eww19_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Vậy định nghĩa compiler là gì? Là một chương trình giúp biên dịch từ một ngôn ngữ bậc cao xuống một ngôn ngữ cấp thấp(thường là machine code).
Ngược lại với compiler là decompiler, giúp dịch ngược từ một ngôn ngữ bậc thấp lên một ngôn ngữ bậc cao. Nghe giống reverse engineering? Chính xác thì decompilation chỉ là một kĩ thuật trong reverse engineering.
Ngoài ra còn có transpiler – dịch từ một ngôn ngữ bậc cao sang một ngôn ngữ bậc cao khác. Ví dụ như babel trong JS, là một trình giúp dịch từ ES6 xuống ES5.&lt;/p&gt;

&lt;h1 id=&#34;cách-hoạt-động-của-một-compiler&#34;&gt;Cách hoạt động của một compiler&lt;/h1&gt;

&lt;p&gt;Một compiler khi hoạt động sẽ có 2 phases: frontend và backend. Theo một số tài liệu thì họ chia ra thêm 1 phase là middle end nằm chính giữa nhưng theo mình thì 2 phases là đủ.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/a4x6hpr62u_blob&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Frontend compiler: Ở phase này, mã nguồn cấp cao sẽ được transform thành IR(Intermediate Representation). &lt;strong&gt;Nhớ IR này nha&lt;/strong&gt;. Các bạn tạm hiểu đây là một data structure  nằm trung gian giữa front end và backend compiler, mà được thiết kế để dễ dàng hơn trong việc optimize và translate. Một IR phải có độ chính xác tuyệt đối(có thể represent mã nguồn mà không mất thông tin). Các công việc sẽ làm ở front end bao gồm:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Phân tích mã nguồn, kiểm tra cú pháp và ngữ nghĩa&lt;/li&gt;
&lt;li&gt;Type checking&lt;/li&gt;
&lt;li&gt;Sinh ra error và warning nếu có.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Backend compiler sẽ nhận vào output của front end. Công việc chính của backend sẽ là code optimization và code generation. Backend phần nhiều sẽ hỗ trợ các nền tảng(CPU) khác nhau. Các bước optimization của backend sẽ dựa trên tập lệnh của chip.
Ví dụ:
Một số chip khi thực hiện phép chia nó sẽ trả về kết quả ở một register, và số dư ở một register khác. Nên nếu trong chương trình có 2 lệnh kế nhau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c = a/b
d = a%b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;=&amp;gt; Backend compiler optimization sẽ hiểu điều này chỉ thực hiện một operation.&lt;/p&gt;

&lt;p&gt;Vậy output của backend compiler là gì?&lt;/p&gt;

&lt;p&gt;Backend compiler của các ngôn ngữ sẽ produce ra các loại output khác nhau. Có 3 loại output chính:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Assembly code.(gcc của C)&lt;/li&gt;
&lt;li&gt;Bytecodes. (javac của Java, Smalltalk)&lt;/li&gt;
&lt;li&gt;Machine code. (Go compiler, Rust compiler)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sở dĩ có sự khác nhau này là do cách tiếp cận của các ngôn ngữ. Ví dụ Java compiler(javac) sau khi compile xong, JVM sẽ nhận input là java bytecodes từ javac, sau đó tiến hành các bước optimization bằng JIT(Just in time compiler) và translation qua machine code(ở runtime).&lt;/p&gt;

&lt;p&gt;Còn với C, output của gcc sẽ là assembly code. Để chuyển hóa thành machine code cần thêm một utility tool gọi là assembler. (Với MS compiler thì trực tiếp build ra machine code luôn). Lí do để chỉ produce ra assembly code là để chia nhỏ công việc, dễ debug compiler. Nếu so với compilation thì việc translate từ assembly qua machine code khá đơn giản.&lt;/p&gt;

&lt;h1 id=&#34;mir-thì-có-gì-khác-biệt&#34;&gt;MIR thì có gì khác biệt?&lt;/h1&gt;

&lt;p&gt;Kiến thức cơ bản đã xong, giờ thì chúng ta sẽ đi sâu vào MIR trong Rust.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/8w0o9dboed_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Ở trên mình có giới thiệu về IR. MIR là mid-level IR, trên hình trên nó nằm giữa 2 cái là HIR - cái này thường là cây AST, và LIR hay là LLVM, cái IR magic nhất mọi thời đại. :lol:&lt;/p&gt;

&lt;p&gt;Vậy MIR trong Rust được sinh ra để làm gì?
MIR là key của các việc sau:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compile nhanh hơn: MIR được thiết kế để giúp compiler của Rust có thể &lt;em&gt;incremental&lt;/em&gt;. Tức là nó sẽ calculate được phần nào mới và chỉ build lại phần đó, giúp cut down được một khoản thời gian đáng kể.&lt;/li&gt;
&lt;li&gt;Execute nhanh hơn: Các bạn nhìn vào hình bên trái, khi mà lúc trước chỉ có một mình thằng LLVM làm nhiệm vụ optimization, thì với MIR, một số bước optimization cho riêng Rust sẽ được thực thi.&lt;/li&gt;
&lt;li&gt;Type checking chính xác hơn.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ở trên chỉ là những cái mà developers có thể thấy. Vậy behind the scene thì sao?&lt;/p&gt;

&lt;h1 id=&#34;behind-the-sence&#34;&gt;Behind the sence&lt;/h1&gt;

&lt;h2 id=&#34;mir-biến-rust-thành-đơn-nhân&#34;&gt;MIR biến Rust thành đơn nhân&lt;/h2&gt;

&lt;p&gt;MIR sẽ remove toàn bộ keywords &lt;code&gt;for&lt;/code&gt;,  &lt;code&gt;match&lt;/code&gt; dùng trong loop và expression, và cả method call. Sau đó thay thế bằng primitive objects.&lt;/p&gt;

&lt;p&gt;Ví dụ, một đoạn code Rust như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for elem in vec {
    process(elem);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Việc gọi &lt;code&gt;for&lt;/code&gt; chỉ đơn giản là iterator gọi next liên tục cho tới khi hết phần tử. Nên nó sẽ được viết lại như này:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let mut iterator = vec.into_iter();
while let Some(elem) = iterator.next() {
    process(elem);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;và cuối cùng được tranlaste bởi MIR thành:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let mut iterator = IntoIterator::into_iter(vec);

loop:
    match Iterator::next(&amp;amp;mut iterator) {
        Some(elem) =&amp;gt; { process(elem); goto loop; }
        None =&amp;gt; { goto break; }
    }

break:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vậy thì tại sao?&lt;/p&gt;

&lt;p&gt;Thứ nhất, đích đến tiếp theo của MIR sẽ là LLVM, mục tiêu là để:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Borrow checking&lt;/li&gt;
&lt;li&gt;Optimize performance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MIR primitive sau khi thay thế sẽ xịn hơn các construct ban đầu. Điểm đặc biệt ở đây là, &lt;code&gt;for&lt;/code&gt; và &lt;code&gt;match&lt;/code&gt; sẽ được replace thành &lt;code&gt;goto&lt;/code&gt;. Việc đưa xuống LLVM với số lượng construct càng ít sẽ được quy về các pattern càng nhỏ, dẫn đến việc optimize dễ dàng hơn.&lt;/p&gt;

&lt;p&gt;Thứ hai, cấu trúc trong MIR là type driven. Ví dụ &lt;code&gt;iterator.next()&lt;/code&gt; sẽ được desugar thành &lt;code&gt;Iterator::next(&amp;amp;mut iterator)&lt;/code&gt;.  Các bạn có thể thấy, MIR sẽ provide thêm đầy đủ trait và type information cho &lt;code&gt;interator&lt;/code&gt; để biết được hàm next() từ đâu gọi.&lt;/p&gt;

&lt;p&gt;Thứ ba, MIR làm tường minh mọi type trong Rust. Việc tường minh này giúp LLVM analyse borrow checking tốt hơn.&lt;/p&gt;

&lt;h2 id=&#34;khái-niệm-control-flow-graph&#34;&gt;Khái niệm control-flow graph.&lt;/h2&gt;

&lt;p&gt;Nhìn ở trên ta thấy MIR được translate ra dưới dạng text, nhưng thực tế bên trong compiler, MIR được biểu diễn thành một luồng điều khiển ở dạng graph, gọi tắt là CFG.&lt;/p&gt;

&lt;p&gt;Ví dụ trên sẽ được vẽ thành:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/9nzjunthry_blob&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Thực ra, bất kì compiler nào cũng đều translate ra CFG và đưa xuống cho LLVM, nhưng MIR khác ở chỗ: cái CFG mà nó translate ra match một cách hoàn hảo với cấu trúc của LLVM IR(cũng là CFG), trong khi các compiler khác không chú trọng chuyện này =&amp;gt; có thể xảy ra sự không chính xác.&lt;/p&gt;

&lt;h2 id=&#34;tối-giản-biểu-thức-match&#34;&gt;Tối giản biểu thức &lt;code&gt;match&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;MIR sẽ đơn giản hóa biểu thức &lt;code&gt;match&lt;/code&gt; ở trên thành những operations nhỏ. Cụ thể:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;match Iterator::next(&amp;amp;mut iterator) {
    Some(elem) =&amp;gt; process(elem),
    None =&amp;gt; break,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở đoạn code trên khi nó đã wrap lại 2 bước thành 1 bước, một là check xem thử có &lt;code&gt;Some&lt;/code&gt;(tức là còn elem nào không), hai là extract cái giá trị của elem đó ra(trong Rust gọi là downcasting).&lt;/p&gt;

&lt;p&gt;Khi qua MIR, nó sẽ trở thành:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop:
    // Put the value we are matching on into a temporary variable.
    let tmp = Iterator::next(&amp;amp;mut iterator);

    // Next, we &amp;quot;switch&amp;quot; on the value to determine which it has.
    switch tmp {
        Some =&amp;gt; {
            // If this is a Some, we can extract the element out
            // by &amp;quot;downcasting&amp;quot;. This effectively asserts that
            // the value `tmp` is of the Some variant.
            let elem = (tmp as Some).0;

            // The user&#39;s original code:
            process(elem);

            goto loop;
        }
        None =&amp;gt; {
            goto break;
        }
    }

break:
    ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Các bạn có thể thấy, &lt;code&gt;match&lt;/code&gt; đã bị replace thành &lt;code&gt;switch&lt;/code&gt; và &lt;code&gt;downcasting&lt;/code&gt;
 Tại sao lại tách ra? Lí do là vì match quá phức tạp, và mục tiêu vẫn là làm sao để LLVM có thể phát huy tối đa khả năng optimization, nên dùng switch sẽ đơn giản hơn.&lt;/p&gt;

&lt;h2 id=&#34;drops-và-panic-tường-minh&#34;&gt;Drops và Panic tường minh&lt;/h2&gt;

&lt;p&gt;Trên ví dụ trên, ta đã vô hình assume rằng mọi chuyện đều xảy ra như ý muốn. Nhưng trong thực tế thì&amp;hellip; hên xui. Đừng lo, MIR sẽ thêm thắt vào các drops(hay còn gọi là destruction) và panic operation vào trong CFG.&lt;/p&gt;

&lt;p&gt;Nó thành thế này đây
 &lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/hb5e7si3o_blob&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Trên đây là overview thiết kế của MIR. Các bạn có thể thấy, MIR có ý nghĩa trong việc giảm độ phức tạp của từng câu lệnh, lại gần với LLVM IR hơn. Việc này giúp dễ phát triển các pattern cho việc optimize.&lt;/p&gt;

&lt;p&gt;Tóm lại thì, MIR được Rust đầu tư với hi vọng trở thành một ngọn cờ đầu của compiler evolution, khi mà tất cả các lý thuyết của nó đều quá hoàn hảo. Mục tiêu ban đầu của MIR là sẽ ôm xô một số công việc từ HIR và LLVM.&lt;/p&gt;

&lt;p&gt;MIR sắp ra đời rồi, mọi người đón chờ xem nhé :laclac:&lt;/p&gt;

&lt;p&gt;Nguồn tham khảo: &lt;a href=&#34;https://blog.rust-lang.org/2016/04/19/MIR.html&#34;&gt;https://blog.rust-lang.org/2016/04/19/MIR.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Viết một facebook messenger bot đơn giản cùng Go &#43; ngrok</title>
      <link>https://runivn.github.io/post/go-facebook-bot/</link>
      <pubDate>Thu, 18 Aug 2016 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-facebook-bot/</guid>
      <description>

&lt;p&gt;Messenger bots của facebook ra cũng khá lâu rồi. Đã có nhiều người sử dụng cho page facebook của mình. Bài này của mình sẽ hướng dẫn các bạn viết 1 con bot tự động trả lời theo pattern có sẵn bằng Go - cho server và ngrok - để publish localhost ra ngoài.&lt;/p&gt;

&lt;p&gt;Kiểu này:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%201.43.47%20PM.png_tigvw7dimg&#34; class=&#34;img-center&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Những thứ bạn cần có:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Một page facebook&lt;/li&gt;
&lt;li&gt;Nhiêu đủ rồi&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;facebook-stuffs&#34;&gt;Facebook stuffs&lt;/h1&gt;

&lt;p&gt;Đầu tiên bạn vào &lt;a href=&#34;https://developers.facebook.com&#34;&gt;https://developers.facebook.com&lt;/a&gt; và chọn app của mình.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%201.49.49%20PM.png_bectpu8v2e&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Ở tab bên trái các bạn &lt;code&gt;Add Product&lt;/code&gt;. Chọn &lt;code&gt;Webhooks&lt;/code&gt;, và &lt;code&gt;New Subscription&lt;/code&gt; và chọn &lt;code&gt;Page&lt;/code&gt; ở dropdown. Sẽ hiện ra cái popup như này:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%201.51.56%20PM.png_4suocqh1zi&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Ở đây mình chỉ chọn subscription field là &lt;code&gt;messages&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Để có thể lưu cái subscription này lại, bạn cần một &lt;code&gt;Callback URL&lt;/code&gt; và một &lt;code&gt;Verify token&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Callback URL là nơi mà messenger sẽ gửi data khi nhận được message trên page của facebook.
Ở đây mình sẽ sử dụng Go làm server, chạy trên localhost. Sau đó dùng ngrok publish ra một https URL(vì Callback URL facebook chỉ nhận https)&lt;/p&gt;

&lt;p&gt;Verify token thì bạn điền token mà mình muốn verify lại 1 lần nữa(sử dụng trong Go server để double check)&lt;/p&gt;

&lt;p&gt;Ta da! Để cái popup này lại đấy, chuyển sang viết server.&lt;/p&gt;

&lt;h1 id=&#34;go-server&#34;&gt;Go server&lt;/h1&gt;

&lt;p&gt;Tạo 1 file &lt;code&gt;main.go&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Viết hàm main cho nó, làm nhiệm vụ là serve ở port 8085 một cái webhook.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	http.HandleFunc(&amp;quot;/webhook&amp;quot;, webhookHandler)
	http.ListenAndServe(&amp;quot;:8085&amp;quot;, nil)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Viết hàm &lt;code&gt;webhookHandler&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func webhookHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method == &amp;quot;GET&amp;quot; {
		verifyTokenAction(w, r)
	}
	if r.Method == &amp;quot;POST&amp;quot; {
		webhookPostAction(w, r)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tại sao lại có 2 hàm GET và POST ở đây? GET sẽ được gọi khi bạn bấm nút &lt;code&gt;Verify and Save&lt;/code&gt; ở popup phía trên. Còn POST sẽ được gọi khi có ai đó nhắn tin trên facebook page. Với GET thì mình chỉ check xem có gửi đúng &lt;code&gt;verifyToken&lt;/code&gt; không, và log ra thôi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func verifyTokenAction(w http.ResponseWriter, r *http.Request) {
	if r.URL.Query().Get(&amp;quot;hub.verify_token&amp;quot;) == verifyToken {
		log.Print(&amp;quot;verify token success.&amp;quot;)
		fmt.Fprintf(w, r.URL.Query().Get(&amp;quot;hub.challenge&amp;quot;))
	} else {
		log.Print(&amp;quot;Error: verify token failed.&amp;quot;)
		fmt.Fprintf(w, &amp;quot;Error, wrong validation token&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quan trọng là xử lý hàm POST:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func webhookPostAction(w http.ResponseWriter, r *http.Request) {
	var receivedMessage ReceivedMessage
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Print(err)
	}
	if err = json.Unmarshal(body, &amp;amp;receivedMessage); err != nil {
		log.Print(err)
	}
	messagingEvents := receivedMessage.Entry[0].Messaging
	for _, event := range messagingEvents {
		senderID := event.Sender.ID
		if &amp;amp;event.Message != nil &amp;amp;&amp;amp; event.Message.Text != &amp;quot;&amp;quot; {
			message := getReplyMessage(event.Message.Text)
			sendTextMessage(senderID, message)
		}
	}
	fmt.Fprintf(w, &amp;quot;Success&amp;quot;)
}
func getReplyMessage(receivedMessage string) string {
	var message string
	receivedMessage = strings.ToUpper(receivedMessage)
	log.Print(&amp;quot; Received message: &amp;quot; + receivedMessage)

    if strings.Contains(receivedMessage, &amp;quot;HELLO&amp;quot;) {
		message = &amp;quot;Hi, my name is Annie. Nice to meet you&amp;quot;
	}

	return message
}

func sendTextMessage(senderID string, text string) {
	recipient := new(Recipient)
	recipient.ID = senderID
	sendMessage := new(SendMessage)
	sendMessage.Recipient = *recipient
	sendMessage.Message.Text = text
	sendMessageBody, err := json.Marshal(sendMessage)
	if err != nil {
		log.Print(err)
	}
	req, err := http.NewRequest(&amp;quot;POST&amp;quot;, FacebookEndPoint, bytes.NewBuffer(sendMessageBody))
	if err != nil {
		log.Print(err)
	}
	fmt.Println(&amp;quot;%T&amp;quot;, req)
	fmt.Println(&amp;quot;%T&amp;quot;, err)

	values := url.Values{}
	values.Add(&amp;quot;access_token&amp;quot;, accessToken)
	req.URL.RawQuery = values.Encode()
	req.Header.Add(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json; charset=UTF-8&amp;quot;)
	client := &amp;amp;http.Client{Timeout: time.Duration(30 * time.Second)}
	res, err := client.Do(req)
	if err != nil {
		log.Print(err)
	}
	defer res.Body.Close()
	var result map[string]interface{}
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Print(err)
	}
	if err := json.Unmarshal(body, &amp;amp;result); err != nil {
		log.Print(err)
	}
	log.Print(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hàm trên có 2 hàm:
- &lt;code&gt;getReplyMessage&lt;/code&gt;: Ở đây mình chỉ xem thử nếu có chữ hello thì mình sẽ trả về message greeting tương ứng. Các bạn có thể sử dụng các kĩ thuật khác cao cấp hơn.
- &lt;code&gt;sendTextMessage&lt;/code&gt;: Hàm này sẽ gửi về POST request về facebook endpoint, sau đó facebook sẽ gửi tin nhắn tới người nhận(người vừa mới chat trên page facebook).&lt;/p&gt;

&lt;p&gt;Chạy server lên bằng &lt;code&gt;go run main.go&lt;/code&gt;. Ta được một server đang chạy ở port 8085&lt;/p&gt;

&lt;h1 id=&#34;ngrok&#34;&gt;Ngrok&lt;/h1&gt;

&lt;p&gt;Các bạn tải ngrok về ở đây &lt;a href=&#34;https://ngrok.com/&#34;&gt;https://ngrok.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chạy ngrok:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngrok http 8085
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sẽ được như này:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%202.39.47%20PM.png_95j7zf1bgb&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;localhost:8085&lt;/code&gt; đã được ngrok chuyển thành &lt;code&gt;https&lt;/code&gt; và publish ra bên ngoài.&lt;/p&gt;

&lt;h1 id=&#34;config&#34;&gt;Config&lt;/h1&gt;

&lt;p&gt;Mọi thứ gần như đã xong. Các bạn chỉ cần paste callback URL đã được forward bởi ngrok vào popup của facebook lúc nãy, điền verify token là xong rồi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-07-08%20at%202.43.19%20PM.png_oe8usmiac8&#34; class=&#34;img-center&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Như vậy là các bạn có thể pm facebook page chat thử và chờ response.&lt;/p&gt;

&lt;h1 id=&#34;kết&#34;&gt;Kết&lt;/h1&gt;

&lt;p&gt;Trên này là một sample đơn giản. Facebook messenger bots có rất nhiều tiềm năng trong lĩnh vực bán hàng hay trả lời tự động. Các bạn nào chưa nghịch thì có thể nghịch thử.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dùng selenium để crawl dữ liệu(Go lang)</title>
      <link>https://runivn.github.io/post/go-selenium/</link>
      <pubDate>Fri, 26 Feb 2016 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/go-selenium/</guid>
      <description>

&lt;h2 id=&#34;crawl-dữ-liệu&#34;&gt;Crawl dữ liệu&lt;/h2&gt;

&lt;p&gt;Crawl là một vấn đề hay gặp trong quá trình làm software. Ví dụ lấy tin tức, tin giảm giá, vé xem phim&amp;hellip; là những dạng của crawl. Một cách khá đơn giản đó là phân tích HTML, đọc các thẻ và rút trích dữ liệu. Thư viện trên Go mình hay dùng đó là &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;goquery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tuy nhiên việc crawl một trang bằng đọc HTML thuần sẽ không work được trong một số trường hợp như: dữ liệu được load bằng ajax(lúc đọc HTML sẽ chỉ thấy wrapper chứ không thấy dữ liệu) hay muốn vào được trang cần crawl thì phải qua bước login,&amp;hellip;&lt;/p&gt;

&lt;p&gt;Trong bài này mình sẽ lấy một ví dụ, mình muốn crawl lấy những giảm giá của amazon: &lt;a href=&#34;http://www.amazon.com/gp/goldbox/all-deals/ref=gbps_ftr_s-3_3022_wht_541966?ie=UTF8&amp;amp;*Version*=1&amp;amp;*entries*=0&amp;amp;gb_f_GB-SUPPLE=sortOrder:BY_SCORE,enforcedCategories:3760911%252C2335752011%252C541966&amp;amp;pf_rd_p=2292853022&amp;amp;pf_rd_s=slot-3&amp;amp;pf_rd_t=701&amp;amp;pf_rd_i=gb_all&amp;amp;pf_rd_m=ATVPDKIKX0DER&amp;amp;pf_rd_r=14CQSB5TF4GTC2RNHDAG&#34;&gt;amazon deal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Trang này javasript sẽ gọi ajax lấy dữ liệu và sau đó mới đổ vào cây DOM. Khi dùng goquery đọc HTML thì sẽ không thấy được các thẻ div như khi inspect element.&lt;/p&gt;

&lt;p&gt;Với những loại như thế này, mình sử dụng selenium để chạy web trên browser thật, thực hiện thao tác để được trang HTML fully load rồi mới trích xuất dữ liệu.&lt;/p&gt;

&lt;p&gt;Selenium chạy trên nền JVM, khá nổi tiếng trong lĩnh vực automation test. Nó cho phép mình chạy script test trên browser thật.
Cách làm của mình sẽ là: Dùng selenium chạy trang amazon lên, đợi javascript load xong và sau đó crawl dữ liệu bình thường.&lt;/p&gt;

&lt;h2 id=&#34;cách-cài-đặt&#34;&gt;Cách cài đặt&lt;/h2&gt;

&lt;p&gt;Đầu tiên các bạn vào link của &lt;a href=&#34;http://docs.seleniumhq.org/download/&#34;&gt;seleniumhq&lt;/a&gt; để tải và cài đặt seleniumhq. Seneliumhq đóng vai trò như là một server, sẽ nhận các request được gửi từ code Go của mình.&lt;/p&gt;

&lt;p&gt;Để chạy, chúng ta vào thư mục chứa file jar và chạy câu lệnh:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -jar selenium-server-standalone-2.50.1.jar -port 8081&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-ap-southeast-1.amazonaws.com/kipalog.com/Screen%20Shot%202016-02-26%20at%203.57.22%20PM.png_uka1cbcuxl&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;=&amp;gt;&amp;gt; Chúng ta được một server selenium chạy ở port 8081.&lt;/p&gt;

&lt;p&gt;Tiếp theo các bạn kéo goselenium về bằng go get:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go get sourcegraph.com/github.com/sourcegraph/go-selenium&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Việc kế tiếp là cài đặt browser, mình chọn Firefox. Các bạn lưu ý, khi chạy trên local thì chỉ cần cài đặt Firefox trên web là được. Còn khi setup trên host thì các bạn cần cài đặt firefox bằng shell script. Các bạn có thể tham khảo &lt;a href=&#34;https://gist.github.com/curtismcmullan/7be1a8c1c841a9d8db2c&#34;&gt;cách setup selenium trên Ubuntu 14.04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Setup đã xong! Giờ vào code Go thôi.&lt;/p&gt;

&lt;p&gt;Chúng ta cần:
- Remote vào server selenium
- Truy xuất tới đường dẫn amazon deal
- Tiến hành phân tích HTML để lấy thông tin, mình sẽ in ra thông tin page title và image sản phẩm đầu tiên.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var webDriver selenium.WebDriver
	var err error
    // set browser as firefox
	caps := selenium.Capabilities(map[string]interface{}{&amp;quot;browserName&amp;quot;: &amp;quot;firefox&amp;quot;})
    // remote to selenium server
	if webDriver, err = selenium.NewRemote(caps, &amp;quot;http://localhost:8081/wd/hub&amp;quot;); err != nil {
		fmt.Printf(&amp;quot;Failed to open session: %s\n&amp;quot;, err)
		return
	}
	defer webDriver.Quit()

	err = webDriver.Get(URL_AMAZON_DEAL)
	if err != nil {
		fmt.Printf(&amp;quot;Failed to load page: %s\n&amp;quot;, err)
		return
	}
	// sleep for a while for fully loaded javascript
	time.Sleep(4 * time.Second)
	// get title
	if title, err := webDriver.Title(); err == nil {
		fmt.Printf(&amp;quot;Page title: %s\n&amp;quot;, title)
	} else {
		fmt.Printf(&amp;quot;Failed to get page title: %s&amp;quot;, err)
		return
	}

	var elem selenium.WebElement
	elem, err = webDriver.FindElement(selenium.ByCSSSelector, &amp;quot;#widgetContent&amp;quot;)
	if err != nil {
		fmt.Printf(&amp;quot;Failed to find element: %s\n&amp;quot;, err)
		return
	}

	var firstElem selenium.WebElement
	firstElem, err = elem.FindElement(selenium.ByCSSSelector, &amp;quot;.a-section .dealContainer&amp;quot;)
	if err != nil {
		fmt.Printf(&amp;quot;Failed to find element: %s\n&amp;quot;, err)
		return
	}
    // get image
	image, err := firstElem.FindElement(selenium.ByCSSSelector, &amp;quot;img&amp;quot;)
	if err == nil {
		img, _ := image.GetAttribute(&amp;quot;src&amp;quot;)
		fmt.Println(img)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy code lên chúng ta được&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Page title: Gold Box Deals | Today&#39;s Deals - Amazon.com
https://images-na.ssl-images-amazon.com/images/I/51eU5JrGAXL._AA210_.jpg&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã lấy được thông tin cần lấy.&lt;/p&gt;

&lt;h2 id=&#34;kết-luận&#34;&gt;Kết luận&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được khi gặp vấn đề về crawl trong quá trình software development, ở đây là ngôn ngữ Go.
Selenium có thể giúp chúng ta trong nhiều trường hợp khác, ví dụ những trang web cần đăng nhập, các trang web có captcha&amp;hellip;
Nếu ai có kinh nghiệm gì khác, mong các bạn đóng góp thêm.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Giới thiệu Interface trong GoLang</title>
      <link>https://runivn.github.io/post/interface-go/</link>
      <pubDate>Thu, 10 Sep 2015 13:09:56 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/interface-go/</guid>
      <description>

&lt;p&gt;Trong bài này mình sẽ trình bày những gì mình tìm hiểu được về interface trong Go, khái niệm, khai báo cũng như cách sử dụng và một vài ví dụ thực tế.&lt;/p&gt;

&lt;h2 id=&#34;khái-niệm&#34;&gt;Khái niệm&lt;/h2&gt;

&lt;p&gt;Interface là một dạng wrapper các khai báo hàm(chỉ là tên của hàm) ở mức độ prototype. Các hàm này sẽ được định nghĩa ở các lớp dẫn xuất, mỗi lớp dẫn xuất sẽ có cách định nghĩa lại hàm khác nhau tương ứng với mục đích sử dụng&lt;/p&gt;

&lt;h2 id=&#34;khai-báo&#34;&gt;Khai báo&lt;/h2&gt;

&lt;p&gt;Một interface với hàm SayYourName() trả về một string được khai báo như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Hello interface{
	SayYourName() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;cách-sử-dụng&#34;&gt;Cách sử dụng&lt;/h2&gt;

&lt;p&gt;Interface trong Go follow concept Duck typing như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có nghĩa là nếu một con nào có thể đi như con vịt, bơi như con vịt và quạc quạc như con vịt thì tôi gọi đó là con vịt.&lt;/p&gt;

&lt;p&gt;Mình sẽ đưa một ví dụ cụ thể. Mình có struct User, struct này có một hàm SayYourName()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
type User struct {
	FirstName, LastName string
}

func (u *User) SayYourName() string {
	return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, u.FirstName, u.LastName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một hàm có param là interface Hello và trả về một string&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Greet(n Hello) string {
	return fmt.Sprintf(&amp;quot;Dear %s&amp;quot;, n.SayYourName())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở đây, hàm Greet nhận vào một param là interface Hello, và nó cũng chấp nhận &lt;b&gt;bất cứ param nào nếu nó có hàm SayYourName&lt;/b&gt;.
Thử chạy chương trình:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	u := &amp;amp;User{&amp;quot;Runi&amp;quot;, &amp;quot;Lazy&amp;quot;}
	fmt.Println(Greet(u))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thật vậy ta có, kết quả &amp;ldquo;Dear Runi Lazy&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Chú ý là param truyền vào hàm Greet phải là những đối tượng có thể có chứa các hàm của riêng đối tượng đó, nhưng bắt buộc phải có  &lt;b&gt;tất cả&lt;/b&gt; những hàm của interface Hello. Giả sử thêm vào interface này một hàm Goodbye():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Hello interface{
	SayYourName() string
	Goodbye() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kết quả ta bị báo lỗi như sau:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://runivn.github.io/post/img/interface-wrong.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-interface-trong-go&#34;&gt;Sử dụng Interface trong Go&lt;/h2&gt;

&lt;p&gt;Ngoài interface có chứa khai báo hàm, interface còn một khái niệm là empty interface, hay interface{}.
Interface này không có hàm, cũng có nghĩa là tất cả các loại variables hay struct&amp;hellip; đều có thể thoả mãn làm param cho hàm nhận vào empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func DoSomething(v interface{}) {
   // ...
}
//Hàm này nhận vào bất cứ loại param nào.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy ta có thể sử dụng empty interface cho các hàm nào mà param truyền vào vẫn chưa xác định cụ thể. Khi vào trong hàm thì tuỳ trường hợp sẽ có các cách tuỳ biến để convert về giá trị chúng ta cần.&lt;/p&gt;

&lt;p&gt;Ví dụ, ta có hàm PrintAll nhận vào một mảng giá trị empty interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func PrintAll(vals []interface{}) {
    for _, val := range vals {
        fmt.Println(val)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong hàm main ta tiến hành convert:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
func main() {
    names := []string{&amp;quot;stanley&amp;quot;, &amp;quot;david&amp;quot;, &amp;quot;oscar&amp;quot;}
    vals := make([]interface{}, len(names))
    for i, v := range names {
        vals[i] = v
    }
    PrintAll(vals)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Một ví dụ khác, mình sưu tầm từ blog &lt;a href=&#34;http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go&#34;&gt;how to use interface in Go&lt;/a&gt;:
Khi nhận response từ Twitter API thì date time có dạng timestamp như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Thu May 31 00:00:01 +0000 2012&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dưới dây là một hàm dùng để in ra kiểu của timeStamp khi nhận từ response:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var input = `
{
    &amp;quot;created_at&amp;quot;: &amp;quot;Thu May 31 00:00:01 +0000 2012&amp;quot;
}
`

func main() {
    var val map[string]interface{}

    if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
        panic(err)
    }

    fmt.Println(val)
    for k, v := range val {
        fmt.Println(k, reflect.TypeOf(v))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy hàm trên ta được :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://runivn.github.io/post/img/return-twitter.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Hum.. timeStamp mà lại kiểu string thì chưa hợp lý lắm, thử parse lại về trực tiếp kiểu time.Time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var val map[string]time.Time
    if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
        panic(err)
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thử chạy lại:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://runivn.github.io/post/img/panic-interface.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Lỗi này xảy ra vì không thể parse chuỗi kia về time.Time được (Twitter API được viết bằng Ruby, cách parse sẽ khác với Go).
Vậy chúng ta thử viết lại hàm parse chuỗi. Ta có interface Unmarshal, được lấy từ &lt;a href=&#34;http://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;Encode Json Package&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Unmarshaler interface {
    UnmarshalJSON([]byte) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta cần viết lại hàm UnmarshalJSON để có thể parse về timeStamp(sử dụng RubyDate)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Timestamp time.Time

func (t *Timestamp) UnmarshalJSON(b []byte) error {
     v, err := time.Parse(time.RubyDate, string(b[1:len(b)-1]))
    if err != nil {
        return err
    }
    *t = Timestamp(v)
    return nil
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Khi đó, hàm main sẽ được viết lại như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	var val map[string]Timestamp

	if err := json.Unmarshal([]byte(input), &amp;amp;val); err != nil {
		panic(err)
	}

	fmt.Println(val)
	for k, v := range val {
		fmt.Println(k, reflect.TypeOf(v))
	}

    fmt.Println(time.Time(val[&amp;quot;created_at&amp;quot;]))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chạy chương trình ta được kết quả:
&lt;img src=&#34;https://runivn.github.io/post/img/interface-timestamp.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Như vậy chúng ta đã vừa tạo một đối tượng có hàm UnmarshalJSON để có thể truyền vào hàm json.Unmarshal trong package encoding/json nhờ đó có được kết quả mong muốn.&lt;/p&gt;

&lt;h2 id=&#34;lời-kết&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được trong quá trình sử dụng interface trong Go. Interface là một trong những kĩ thuật đặc trưng của Go, mong nhận được ý kiến đóng góp từ các bạn.
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hướng dẫn sử dụng Vim để code Go</title>
      <link>https://runivn.github.io/post/vim-go/</link>
      <pubDate>Fri, 04 Sep 2015 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/vim-go/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;Vim là một text-editor khá mạnh, được sử dụng trong môi trường máy chủ không có giao diện đồ họa. Trong bài này mình sẽ giới thiệu Vim căn bản và hướng dẫn các bạn sử dụng Vim như một IDE dành cho Go&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vim-là-gì&#34;&gt;Vim là gì?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vim là text editor cao cấp, phiên bản sau của Vi(Vim = Vi Improved), được viết bởi Bram Moolenaar, lần đầu tiên được đưa ra vào năm 1991.&lt;/li&gt;
&lt;li&gt;Vim thường được gọi à &amp;ldquo;editor dành cho dân lập trình&amp;rdquo;, tuy nhiên nó có thể hầu hết các công việc liên quan tới văn bản như sửa chữa văn bản, soạn thảo email hay sửa file configs.&lt;/li&gt;
&lt;li&gt;Vim có thể sử dụng làm IDE nhờ các plugins&lt;/li&gt;
&lt;li&gt;Vim hỗ trợ đa nền tảng.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cài-đặt-và-config&#34;&gt;Cài đặt và config&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Vim có thể được download tại trang &lt;a href=&#34;http://www.vim.org/download.php&#34;&gt;vim homepage&lt;/a&gt; hoặc cài đặt bằng &lt;a href=&#34;http://brew.sh/&#34;&gt;brew&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     brew install vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vì một số plugins phía sau có thể cần tới lua nên các bạn nên cài với câu lệnh:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     brew install vim --with-lua
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sau khi cài đặt xong, các bạn tạo một file .vimrc ở ~/ (file này không tự động tạo). File .vimrc này sẽ là nơi chứa toàn bộ config, plugins hay bundle cũng như các function liên quan tới vim.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tiếp theo là cài vim plugins manager. Hiện tại mình đang sử dụng &lt;a href=&#34;https://github.com/VundleVim/Vundle.vim&#34;&gt;Vundle&lt;/a&gt;, các bạn có thể sử dụng &lt;a href=&#34;https://github.com/tpope/vim-pathogen&#34;&gt;panthogen&lt;/a&gt; nếu thích.
Vundle sẽ giúp các bạn trong việc config các plugins trong .vimrc, install hay update và một số việc khác.
Để cài đặt, các bạn clone vundle vào thư mục ~/.vim/bundle/ (thư mục .vim sẽ có sau khi cài đặt vim xong)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy vào .vimrc một số configs và các plugin cơ bản (chú ý dấu &amp;ldquo; trong vim là comment)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible              &amp;quot; be iMproved, required
filetype off                  &amp;quot; required

&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&#39;~/some/path/here&#39;)

&amp;quot; let Vundle manage Vundle, required
Plugin &#39;VundleVim/Vundle.vim&#39;

&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
Plugin &#39;tpope/vim-fugitive&#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
Plugin &#39;L9&#39;
&amp;quot; Git plugin not hosted on GitHub
Plugin &#39;git://git.wincent.com/command-t.git&#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
Plugin &#39;file:///home/gmarik/path/to/plugin&#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
Plugin &#39;rstacruz/sparkup&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}
&amp;quot; Avoid a name conflict with L9
Plugin &#39;user/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}

&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tiếp theo để install plugins, các bạn mở vim lên và chạy command sau(bằng cách nhấn Esc):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :PluginInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Để update plugins, các bạn sử dụng&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :PluginUpdate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Như vậy là đủ đồ chơi để các bạn có thể sử dụng Vim rồi.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hướng-dẫn-sử-dụng-căn-bản&#34;&gt;Hướng dẫn sử dụng căn bản.&lt;/h2&gt;

&lt;p&gt;Vim là một chương trình soạn thảo được build lần đầu tiên trên UNIX, dùng để làm việc trên môi trường ko có UI. Lúc này bàn phím chưa cũng khá thô sơ, nên các bước di chuyển trên vim hơi khác với bình thường:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://runivn.github.io/post/img/hjkl.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Các bạn có thể tự tập luyện việc sử dụng các phím này bằng &lt;a href=&#34;http://vim-adventures.com/&#34;&gt;vim game&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Để mở một file với vim, các bạn dùng câu lệnh:
        &lt;code&gt;vim file_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Trong vim có 3 mode:
 &amp;ndash; Normal mode - xuất hiện khi bạn ấn Ecs, thường đi kèm đầu tiên bởi dấu &amp;ldquo;:&amp;ldquo;. Ở đây vim sẽ hiểu những gì bạn gõ vào là câu lệnh cho vim. Ví dụ:&lt;code&gt;:w&lt;/code&gt; là save văn bản, &lt;code&gt;:q&lt;/code&gt; là thoát một văn bản.
       Vim có ngôn ngữ riêng dành cho mình, đó là Vim script. Vim script có thể được execute ở normal mode, ví dụ, để in ra Hello world chúng ta dùng:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      :echo &amp;quot;Hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; Insert mode - xuất hiện khi bạn nhấn một trong các nút sau :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      a: Insert vào phía sau con trỏ hiện tại
      A: Insert vào cuối hàng
      i: Insert vào phía trước con trỏ hiện tại
      I: Insert vào đầu hàng
      o: Insert và mở một hàng trống phía dưới
      O: Insert và mở một hàng trống phía trên
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; Visual mode &amp;ndash; xuất hiện khi bạn ấn nút v, được dùng cho việc chọn một mảng block text lớn, có thể sử dụng vào việc copy paste hoặc comment&amp;hellip;&lt;/p&gt;

&lt;p&gt;Các bạn có thể đọc &lt;a href=&#34;http://bullium.com/support/vim.html&#34;&gt;vim command&lt;/a&gt; để biết thêm về các command trong vim.&lt;/p&gt;

&lt;h2 id=&#34;sử-dụng-vim-như-go-ide&#34;&gt;Sử dụng Vim như Go IDE&lt;/h2&gt;

&lt;p&gt;Để sử dụng Vim như một IDE cho Go, chúng ta cần cài đặt một số plugins cho go.&lt;/p&gt;

&lt;p&gt;Quan trọng nhất là &lt;a href=&#34;https://github.com/fatih/vim-go/&#34;&gt;vim go&lt;/a&gt;. Vim go bao gồm tập hợp các thư viện hỗ trợ Go cho vim, ví dụ &lt;code&gt;godef&lt;/code&gt;
   &lt;code&gt;gofmt&lt;/code&gt; &lt;code&gt;go test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Để cài đặt vim go, các bạn copy plugin vào file .vimrc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   Plugin &#39;fatih/vim-go&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sau đó vào normal mode bằng cách nhấn &lt;code&gt;Esc&lt;/code&gt; và gõ command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   :PluginInstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xong, lại tiếp tục gõ command để install Go binaries&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :GoInstallBinaries
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chỉ với Vim-go các bạn đã có thể code Go được rồi, nhưng để mọi thứ dễ nhìn hơn cũng như tăng độ hiệu quả, các bạn nên tìm và cài thêm các plugin sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ack.vim
    bclose.vim
    bufexplorer
    nerdtree
    nerdcommenter
    csapprox
    vim-fugitive
    gitv
    vim-gitgutter
    syntastic
    neocomplete.vim
    neosnippet.vim
    auto-pairs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Trong số này:&lt;/p&gt;

&lt;p&gt;&amp;ndash; nerdtree: Giúp bạn tổ chức folder trong vim dưới dạng cây thư mục, dễ dàng hơn trong việc mở file và folder. Sau khi cài đặt:
&lt;img src=&#34;https://runivn.github.io/post/img/nerdtree.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;Nhờ plugin của git, các bạn có thể biết file nào đang sửa, thêm mới và chưa được commit.&lt;/p&gt;

&lt;p&gt;&amp;ndash; neocomplete: Hỗ trợ auto complete trong vim.
&lt;img src=&#34;https://runivn.github.io/post/img/neocomplete.png&#34; class=&#34;img-center&#34;&gt;&lt;/p&gt;

&lt;p&gt;&amp;ndash; autopair: Plugin giúp bạn gõ nhanh khi sử dụng các dấu &amp;ldquo; ( &amp;lsquo; [ &amp;lt; bằng cách thêm vào thành một pair &amp;ldquo;&amp;rdquo; () &amp;ldquo; [] &amp;lt;&amp;gt;&lt;/p&gt;

&lt;h2 id=&#34;cơ-chế-mapping-trong-vim&#34;&gt;Cơ chế mapping trong Vim&lt;/h2&gt;

&lt;p&gt;Vim có một khái niệm là mapping, cho phép người dùng mode lại các tổ hợp phím để phục vụ các mục đích cá nhân.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Khi tôi nhấn key này, tôi muốn bạn làm hành động này thay vì những gì bạn hay thường làm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ:
  Gõ vài dòng trên văn bản bằng vim, sau đó chạy command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:map - x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Đặt con trỏ của bạn lên văn bản và nhấn &lt;code&gt;-&lt;/code&gt;. Vim lập tức delete kí tự tại vị trí con trỏ, như là bạn đã nhấn &lt;code&gt;x&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Lúc này mapping của bạn chỉ có hiệu quả trên file text mà bạn đang edit, để mapping hoạt động trên toàn bộ các file khác, bạn cần đặt mapping vào trong file .vimrc
Một số loại mapping thường dùng:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  nmap    : sử dụng khi ở chế độ normal
  imap    : sử dụng trong chế độ insert
  vmap    : sử dụng trong chế độ visual
  noremap : không thể bị override bởi mapping khác
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ví dụ, khi code Go chúng ta hay dùng godef để tìm định nghĩa của hàm(biến) đó. Để sử dụng với vim-go chúng ta cần vào normal mode và gõ &lt;code&gt;:GoDef&lt;/code&gt;
Thay vì vậy, mình mapping lại như sau&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nnoremap &amp;lt;silent&amp;gt; df :GoDef&amp;lt;cr&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Có nghĩa là, khi mình ở chế độ normal, ấn tổ hợp df sẽ thực hiện command &lt;code&gt;:GoDef&lt;/code&gt;. Map này không bị override bởi bất kì normal map nào khác.
Như vậy, khi bạn muốn tìm kiếm định nghĩa một hàm hay một biến nào đó, bạn sử dụng tổ hợp phím &lt;code&gt;df&lt;/code&gt;. Việc này giảm thiểu quá trình typing đi khá nhiều.&lt;/p&gt;

&lt;p&gt;Một ví dụ về mapping khác, ví dụ mình hay sử dụng thư viện &lt;a href=&#34;https://github.com/k0kubun/pp&#34;&gt;print&lt;/a&gt; để in ra result ở terminal đẹp hơn. Việc log để debug trong Go diễn ra khá thường xuyên, vì vậy mình đặt một map như sau:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inoremap &amp;lt;silent&amp;gt; pp pp.Println(&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tức là khi mình gõ trong insert mode &lt;code&gt;pp&lt;/code&gt; nó sẽ tự chuyển thành &lt;code&gt;pp.Println(&amp;quot;&amp;quot;)&lt;/code&gt;, điều này giúp mình code nhanh hơn.&lt;/p&gt;

&lt;p&gt;Các bạn có thể đọc thêm về &lt;a href=&#34;http://vimdoc.sourceforge.net/htmldoc/map.html&#34;&gt;mapping in vim &lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;lời-kết&#34;&gt;Lời kết&lt;/h2&gt;

&lt;p&gt;Tất cả mọi thứ dường như đã sẵn sàng! Việc còn lại của bạn là tập luyện:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sử dụng nhuần nhuyễn cách di chuyển trong vim bằng các nút hjkl, cũng như các command cơ bản trong vim.&lt;/li&gt;
&lt;li&gt;Tìm thêm các plugins để hỗ trợ thêm cho vim. Một trang mình thấy khá hay và bổ ích về &lt;a href=&#34;http://vimawesome.com&#34;&gt;plugins cho vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Điểm mạnh của vim chính là customization, các bạn nên tìm cách tạo những mapping hay function giúp tăng tốc độ code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trên đây là những gì mình tìm hiểu được về Vim và cách sử dụng Vim để code Go. Thế giới của Vim có rất nhiều điều để có thể tìm hiểu, mong nhận được sự đóng góp của mọi người.
Nếu có điều gì muốn trao đổi, liên hệ qua mail thach@dwarvesf.com với mình nha.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Một số blogs từ đồng bọn đông đảo của mình</title>
      <link>https://runivn.github.io/post/friends/</link>
      <pubDate>Mon, 18 Aug 2014 16:45:32 +0700</pubDate>
      
      <guid>https://runivn.github.io/post/friends/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://giangnh.me&#34;&gt;IntoIterator::repeat(☕️) - https://giangnh.me&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mquy.github.io&#34;&gt;Minh Quy Blog - https://mquy.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imlinh.com&#34;&gt;Blog I&amp;rsquo;m Linh - https://imlinh.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://trietphm.github.io&#34;&gt;Tea, Coffee &amp;amp; Code - https://trietphm.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hieuk09.github.io&#34;&gt;Saitama&amp;rsquo;s Punch - http://hieuk09.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://runikitkat.com&#34;&gt;Runi Blog - http://runikitkat.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codeaholicguy.com&#34;&gt;Codeaholicguy - https://codeaholicguy.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hieuhtr.github.io&#34;&gt;Hieu&amp;rsquo;s Blog - https://hieuhtr.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://thefullsnack.com&#34;&gt;The Whole Snack Blog - https://thefullsnack.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://huydx.com&#34;&gt;HuyDX&amp;rsquo;s Blog - https://huydx.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sfzxc.github.io/&#34;&gt;Long Hoang&amp;rsquo;s Blog - https://sfzxc.github.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nguyenquangminh0711.github.io&#34;&gt;nguyenquangminh0711&amp;rsquo;s blog -
https://nguyenquangminh0711.github.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>